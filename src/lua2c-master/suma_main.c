/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* name: _M.get_base_componet_path2
 * function () */
static int lcf1__M_get_base_componet_path2 (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* return base_componet_paths[1] */
  lc_getupvalue(L,lua_upvalueindex(1),0,8);
  lua_pushnumber(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 0);
}


/* name: _M.get_base_componet_path
 * function () */
static int lcf1__M_get_base_componet_path (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* return base_componet_paths[1] */
  lc_getupvalue(L,lua_upvalueindex(1),0,8);
  lua_pushnumber(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 0);
}


/* name: _M.key_req_send
 * function (content, pack) */
static int lcf1__M_key_req_send (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local cache_ngx = ngx.shared.ngx_share_dict */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"shared");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ngx_share_dict");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* local params = {  
   * 	    method     = "POST",
   * 	    ssl_verify = false
   * 	} */
  lua_createtable(L,0,2);
  lua_pushliteral(L,"method");
  lua_pushliteral(L,"POST");
  lua_rawset(L,-3);
  lua_pushliteral(L,"ssl_verify");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 4);
  
  /* local auth_url   = KEY_GATE_WAY_RAW */
  lc_getupvalue(L,lua_upvalueindex(1),0,9);
  assert(lua_gettop(L) == 5);
  
  /* params.headers = {} */
  lua_newtable(L);
  lua_pushliteral(L,"headers");
  lua_insert(L,-2);
  lua_settable(L,4);
  assert(lua_gettop(L) == 5);
  
  /* params.headers ["Content-Type"]  = "application/json" */
  lua_pushliteral(L,"application/json");
  lua_pushliteral(L,"headers");
  lua_gettable(L,4);
  lua_insert(L,-2);
  lua_pushliteral(L,"Content-Type");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 5);
  
  /* params.body= pack */
  lua_pushvalue(L,2);
  lua_pushliteral(L,"body");
  lua_insert(L,-2);
  lua_settable(L,4);
  assert(lua_gettop(L) == 5);
  
  /* --cjson.encode(pack);
   * local httpd   	 = http.new() */
  lc_getupvalue(L,lua_upvalueindex(1),7,2);
  lua_pushliteral(L,"new");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  assert(lua_gettop(L) == 6);
  
  /* local rres, rerr = httpd:request_uri(auth_url, params) */
  lua_pushvalue(L,6);
  lua_pushliteral(L,"request_uri");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,5);
  lua_pushvalue(L,4);
  lua_call(L,3,2);
  assert(lua_gettop(L) == 8);
  
  /* -- httpd:set_keepalive(1, 30000)
   * if rres ~= nil then */
  enum { lc10 = 8 };
  lua_pushnil(L);
  const int lc11 = lua_equal(L,7,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc11);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc12 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc12) {
    
    /* if nil ~= rres.body then */
    enum { lc13 = 8 };
    lua_pushnil(L);
    lua_pushliteral(L,"body");
    lua_gettable(L,7);
    const int lc14 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc14);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc15 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc15) {
      
      /* local ecek_result = cjson.decode(rres.body) */
      lc_getupvalue(L,lua_upvalueindex(1),8,1);
      lua_pushliteral(L,"decode");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"body");
      lua_gettable(L,7);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 9);
      
      /* if ecek_result.status ~= "success" then */
      enum { lc16 = 9 };
      lua_pushliteral(L,"status");
      lua_gettable(L,9);
      lua_pushliteral(L,"success");
      const int lc17 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc17);
      lua_pushboolean(L,!(lua_toboolean(L,-1)));
      lua_remove(L,-2);
      const int lc18 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc18) {
        
        /* ngx.ctx.status = "contentIDNotFound" */
        lua_pushliteral(L,"contentIDNotFound");
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"ctx");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"status");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 9);
        
        /* _M.default_response_print() */
        lc_getupvalue(L,lua_upvalueindex(1),2,7);
        lua_pushliteral(L,"default_response_print");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,0,0);
        assert(lua_gettop(L) == 9);
        
        /* ngx.exit(200) */
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"exit");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,200);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 9);
        
        /* return; */
        return 0;
        assert(lua_gettop(L) == 9);
      }
      lua_settop(L,lc16);
      assert(lua_gettop(L) == 9);
      
      /* local value = cache_ngx:set(content.deviceID .. content.contentIDs[1] .. #content.contentIDs .. ".kgw",  rres.body, 1) */
      lua_pushvalue(L,3);
      lua_pushliteral(L,"set");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"deviceID");
      lua_gettable(L,1);
      lua_pushliteral(L,"contentIDs");
      lua_gettable(L,1);
      lua_pushnumber(L,1);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"contentIDs");
      lua_gettable(L,1);
      const double lc19 = lua_objlen(L,-1);
      lua_pop(L,1);
      lua_pushnumber(L,lc19);
      lua_pushliteral(L,".kgw");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      lua_pushliteral(L,"body");
      lua_gettable(L,7);
      lua_pushnumber(L,1);
      lua_call(L,4,1);
      assert(lua_gettop(L) == 10);
      
      /* --10min
       * --local data  = cjson.decode(rres.body);
       * --if data.keyGateWayID ~= nil then
       * --ngx.ctx.serverid = data.keyGateWayID;
       * --end
       * --ngx.log(ngx.ERR , rres.body);
       * return rres.body */
      lua_pushliteral(L,"body");
      lua_gettable(L,7);
      return 1;
      assert(lua_gettop(L) == 10);
    }
    lua_settop(L,lc13);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc10);
  assert(lua_gettop(L) == 8);
  
  /* ngx.log(ngx.ERR, "err:500 key gate way : " .. rerr) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"log");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ERR");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"err:500 key gate way : ");
  lua_pushvalue(L,8);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 8);
  
  /* ngx.log(ngx.ERR, rres) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"log");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ERR");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,7);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 8);
  
  /* ngx.exit(500) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"exit");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,500);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 8);
  
  /* return nil */
  lua_pushnil(L);
  return 1;
  assert(lua_gettop(L) == 8);
}


/* name: _M.pack_license
 * function (node, packer) */
static int lcf1__M_pack_license (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local cache_ngx = ngx.shared.ngx_share_dict */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"shared");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ngx_share_dict");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* local cache     = cache_ngx:get(node.deviceID .. node.contentIDs[1]  .. #node.contentIDs) */
  lua_pushvalue(L,3);
  lua_pushliteral(L,"get");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"deviceID");
  lua_gettable(L,1);
  lua_pushliteral(L,"contentIDs");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"contentIDs");
  lua_gettable(L,1);
  const double lc21 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc21);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 4);
  
  /* -- if cache ~= nil then
   * -- 	return cjson.decode(cache);
   * -- end
   * local content = cencode(packer) */
  lc_getupvalue(L,lua_upvalueindex(1),0,10);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* --ngx.log(ngx.ERR, "license = " .. content);
   * local params = {  
   * 	   method     = "POST",
   * 	   ssl_verify = false ,
   * 	   body       = ""
   * 	} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"method");
  lua_pushliteral(L,"POST");
  lua_rawset(L,-3);
  lua_pushliteral(L,"ssl_verify");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"body");
  lua_pushliteral(L,"");
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 6);
  
  /* params.headers = {
   * 		["Content-Type"] =  "application/json"
   * 	} */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"Content-Type");
  lua_pushliteral(L,"application/json");
  lua_rawset(L,-3);
  lua_pushliteral(L,"headers");
  lua_insert(L,-2);
  lua_settable(L,6);
  assert(lua_gettop(L) == 6);
  
  /* -- params.headers ["Content-Type"]  = "application/json";
   * params.body = content */
  lua_pushvalue(L,5);
  lua_pushliteral(L,"body");
  lua_insert(L,-2);
  lua_settable(L,6);
  assert(lua_gettop(L) == 6);
  
  /* local auth_url   = _M.get_base_componet_path() .. "pack_license" */
  lc_getupvalue(L,lua_upvalueindex(1),3,7);
  lua_pushliteral(L,"get_base_componet_path");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushliteral(L,"pack_license");
  lua_concat(L,2);
  assert(lua_gettop(L) == 7);
  
  /* local httpd   	 = http.new() */
  lc_getupvalue(L,lua_upvalueindex(1),8,2);
  lua_pushliteral(L,"new");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  assert(lua_gettop(L) == 8);
  
  /* -- httpd:set_keepalive(1, 30000)
   * local rres, rerr = httpd:request_uri(auth_url, params) */
  lua_pushvalue(L,8);
  lua_pushliteral(L,"request_uri");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,7);
  lua_pushvalue(L,6);
  lua_call(L,3,2);
  assert(lua_gettop(L) == 10);
  
  /* --if rres ~= nil then
   * -- ngx.log(ngx.ERR, rres.body);
   * -- ngx.log(ngx.ERR , params.body);
   * local ttt = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 11);
  
  /* if nil ~= rres then */
  enum { lc22 = 11 };
  lua_pushnil(L);
  const int lc23 = lua_equal(L,-1,9);
  lua_pop(L,1);
  lua_pushboolean(L,lc23);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc24 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc24) {
    
    /* local item = cjson.decode (rres.body) */
    lc_getupvalue(L,lua_upvalueindex(1),9,1);
    lua_pushliteral(L,"decode");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"body");
    lua_gettable(L,9);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 12);
    
    /* if item.code ~= "000" then */
    enum { lc25 = 12 };
    lua_pushliteral(L,"code");
    lua_gettable(L,12);
    lua_pushliteral(L,"000");
    const int lc26 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc26);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc27 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc27) {
      
      /* ngx.log(ngx.ERR, "err=>" .. rres.body ) */
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"log");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ERR");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"err=>");
      lua_pushliteral(L,"body");
      lua_gettable(L,9);
      lua_concat(L,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 12);
      
      /* if ngx.ctx.status == "success" then */
      enum { lc28 = 12 };
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ctx");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"status");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"success");
      const int lc29 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc29);
      const int lc30 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc30) {
        
        /* ngx.ctx.status = item.details */
        lua_pushliteral(L,"details");
        lua_gettable(L,12);
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"ctx");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"status");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc28);
      assert(lua_gettop(L) == 12);
      
      /* _M.default_response_print() */
      lc_getupvalue(L,lua_upvalueindex(1),3,7);
      lua_pushliteral(L,"default_response_print");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,0,0);
      assert(lua_gettop(L) == 12);
      
      /* ngx.exit(200) */
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"exit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,200);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 12);
      
      /* return; */
      return 0;
      assert(lua_gettop(L) == 12);
    }
    lua_settop(L,lc25);
    assert(lua_gettop(L) == 12);
    
    /* if item.protectedLicenses ~= nil then */
    enum { lc31 = 12 };
    lua_pushliteral(L,"protectedLicenses");
    lua_gettable(L,12);
    lua_pushnil(L);
    const int lc32 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc32);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc33 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc33) {
      
      /* ttt = item.protectedLicenses */
      lua_pushliteral(L,"protectedLicenses");
      lua_gettable(L,12);
      lua_replace(L,11);
      assert(lua_gettop(L) == 12);
    }
    else {
      
      /* else
       * ngx.log(ngx.ERR, "pack listence is block1") */
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"log");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ERR");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"pack listence is block1");
      lua_call(L,2,0);
      assert(lua_gettop(L) == 12);
      
      /* if ngx.ctx.status == "success" then */
      enum { lc34 = 12 };
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ctx");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"status");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"success");
      const int lc35 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc35);
      const int lc36 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc36) {
        
        /* ngx.ctx.status = "abort" */
        lua_pushliteral(L,"abort");
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"ctx");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"status");
        lua_insert(L,-2);
        lua_settable(L,-3);
        lua_pop(L,1);
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc34);
      assert(lua_gettop(L) == 12);
      
      /* --ngx.log(ngx.ERR, rres.body);
       * _M.default_response_print() */
      lc_getupvalue(L,lua_upvalueindex(1),3,7);
      lua_pushliteral(L,"default_response_print");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,0,0);
      assert(lua_gettop(L) == 12);
      
      /* ngx.exit(200) */
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"exit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushnumber(L,200);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 12);
    }
    lua_settop(L,lc31);
    assert(lua_gettop(L) == 12);
    
    /* -- ttt = item.protectedLicenses;
     * -- if (ilen(rres.body) > 30) then
     * -- 	ttt = item.protectedLicenses;
     * -- else
     * -- 	ngx.log(ngx.ERR, "pack listence is block");
     * -- 	if ngx.ctx.status == "success" then
     * -- 		ngx.ctx.status = "abort";
     * -- 	end
     * -- 	--ngx.log(ngx.ERR, rres.body);
     * -- 	_M.default_response_print();
     * -- 	ngx.exit(200);
     * -- 	return ttt;
     * -- end
     * --ngx.log(ngx.ERR, "license" .. tostring(item.details));
     * cache_ngx:set(node.deviceID .. node.contentIDs[1]  .. #node.contentIDs , cencode(ttt) , 1) */
    lua_pushvalue(L,3);
    lua_pushliteral(L,"set");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"deviceID");
    lua_gettable(L,1);
    lua_pushliteral(L,"contentIDs");
    lua_gettable(L,1);
    lua_pushnumber(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"contentIDs");
    lua_gettable(L,1);
    const double lc37 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc37);
    lua_concat(L,2);
    lua_concat(L,2);
    lc_getupvalue(L,lua_upvalueindex(1),0,10);
    lua_pushvalue(L,11);
    lua_call(L,1,1);
    lua_pushnumber(L,1);
    lua_call(L,4,0);
    assert(lua_gettop(L) == 12);
    
    /* return ttt */
    lua_pushvalue(L,11);
    return 1;
    assert(lua_gettop(L) == 12);
  }
  lua_settop(L,lc22);
  assert(lua_gettop(L) == 11);
  
  /* --end
   * ngx.log(ngx.ERR, "pack listence is block2") */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"log");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ERR");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"pack listence is block2");
  lua_call(L,2,0);
  assert(lua_gettop(L) == 11);
  
  /* if ngx.ctx.status == "success" then */
  enum { lc38 = 11 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"status");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"success");
  const int lc39 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc39);
  const int lc40 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc40) {
    
    /* ngx.ctx.status = "abort" */
    lua_pushliteral(L,"abort");
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"status");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc38);
  assert(lua_gettop(L) == 11);
  
  /* _M.default_response_print() */
  lc_getupvalue(L,lua_upvalueindex(1),3,7);
  lua_pushliteral(L,"default_response_print");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,0);
  assert(lua_gettop(L) == 11);
  
  /* ngx.exit(200) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"exit");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,200);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 11);
  
  /* return ttt */
  lua_pushvalue(L,11);
  return 1;
  assert(lua_gettop(L) == 11);
}


/* name: _M.verify_chain
 * function (content) */
static int lcf1__M_verify_chain (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local params = {
   * 	   method     = "POST",
   * 	   ssl_verify = false ,
   * 	   body       = ""
   * 	} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"method");
  lua_pushliteral(L,"POST");
  lua_rawset(L,-3);
  lua_pushliteral(L,"ssl_verify");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"body");
  lua_pushliteral(L,"");
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 2);
  
  /* params.headers = {
   * 		["Content-Type"] =  "application/json"
   * 	} */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"Content-Type");
  lua_pushliteral(L,"application/json");
  lua_rawset(L,-3);
  lua_pushliteral(L,"headers");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* -- params.headers ["Content-Type"]  = "application/json";
   * local pack = {
   * 		["source"] = content
   * 	} */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"source");
  lua_pushvalue(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 3);
  
  /* --content = string.gsub(content, "\"", "%\\"");
   * params.body= cjson.encode(pack) */
  lc_getupvalue(L,lua_upvalueindex(1),9,1);
  lua_pushliteral(L,"encode");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  lua_pushliteral(L,"body");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 3);
  
  /* --params.body = [[{"source":"]].. content ..[["}]];
   * --ngx.log(ngx.ERR, params.body);
   * local auth_url   = _M.get_base_componet_path () .. "verify" */
  lc_getupvalue(L,lua_upvalueindex(1),3,7);
  lua_pushliteral(L,"get_base_componet_path");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushliteral(L,"verify");
  lua_concat(L,2);
  assert(lua_gettop(L) == 4);
  
  /* local httpd   	 = http.new() */
  lc_getupvalue(L,lua_upvalueindex(1),8,2);
  lua_pushliteral(L,"new");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  assert(lua_gettop(L) == 5);
  
  /* -- httpd:set_keepalive(1, 30000)
   * local rres, rerr = httpd:request_uri(auth_url, params) */
  lua_pushvalue(L,5);
  lua_pushliteral(L,"request_uri");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,4);
  lua_pushvalue(L,2);
  lua_call(L,3,2);
  assert(lua_gettop(L) == 7);
  
  /* --if rres ~= nil then
   * if rerr ~= nil then */
  enum { lc41 = 7 };
  lua_pushnil(L);
  const int lc42 = lua_equal(L,7,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc42);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc43 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc43) {
    
    /* ngx.log(ngx.ERR, "_M.verify_chain::" .. rerr ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ERR");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"_M.verify_chain::");
    lua_pushvalue(L,7);
    lua_concat(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc41);
  assert(lua_gettop(L) == 7);
  
  /* if nil ~= rres then */
  enum { lc44 = 7 };
  lua_pushnil(L);
  const int lc45 = lua_equal(L,-1,6);
  lua_pop(L,1);
  lua_pushboolean(L,lc45);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc46 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc46) {
    
    /* --ngx.log(ngx.ERR, "verify" .. rres.body);
     * -- verify_result.code == "000"
     * return rres.body */
    lua_pushliteral(L,"body");
    lua_gettable(L,6);
    return 1;
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc44);
  assert(lua_gettop(L) == 7);
  
  /* --end
   * return nil */
  lua_pushnil(L);
  return 1;
  assert(lua_gettop(L) == 7);
}


/* name: _M.verify
 * function (content) */
static int lcf1__M_verify (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local params = {
   * 	   method     = "POST",
   * 	   ssl_verify = false ,
   * 	   body       = ""
   * 	} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"method");
  lua_pushliteral(L,"POST");
  lua_rawset(L,-3);
  lua_pushliteral(L,"ssl_verify");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"body");
  lua_pushliteral(L,"");
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 2);
  
  /* params.headers = {
   * 		["Content-Type"] =  "application/json"
   * 	} */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"Content-Type");
  lua_pushliteral(L,"application/json");
  lua_rawset(L,-3);
  lua_pushliteral(L,"headers");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* local pack = {
   * 		["source"] = content
   * 	} */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"source");
  lua_pushvalue(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 3);
  
  /* --content = string.gsub(content, "\"", "%\\"");
   * params.body= cjson.encode(pack) */
  lc_getupvalue(L,lua_upvalueindex(1),9,1);
  lua_pushliteral(L,"encode");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  lua_pushliteral(L,"body");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 3);
  
  /* --params.body = [[{"source":"]].. content ..[["}]];
   * --ngx.log(ngx.ERR, params.body);
   * --local auth_url   = "http://192.166.64.22:9555/verify";
   * local auth_url   = _M.get_base_componet_path () .. "verifySignature" */
  lc_getupvalue(L,lua_upvalueindex(1),3,7);
  lua_pushliteral(L,"get_base_componet_path");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushliteral(L,"verifySignature");
  lua_concat(L,2);
  assert(lua_gettop(L) == 4);
  
  /* local httpd   	 = http.new() */
  lc_getupvalue(L,lua_upvalueindex(1),8,2);
  lua_pushliteral(L,"new");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  assert(lua_gettop(L) == 5);
  
  /* -- httpd:set_keepalive(1, 30000)
   * local rres, rerr = httpd:request_uri(auth_url, params) */
  lua_pushvalue(L,5);
  lua_pushliteral(L,"request_uri");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,4);
  lua_pushvalue(L,2);
  lua_call(L,3,2);
  assert(lua_gettop(L) == 7);
  
  /* --if rres ~= nil then
   * if rerr ~= nil then */
  enum { lc47 = 7 };
  lua_pushnil(L);
  const int lc48 = lua_equal(L,7,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc48);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc49 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc49) {
    
    /* ngx.log(ngx.ERR, "verify::" .. rerr ) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ERR");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"verify::");
    lua_pushvalue(L,7);
    lua_concat(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc47);
  assert(lua_gettop(L) == 7);
  
  /* if nil ~= rres then */
  enum { lc50 = 7 };
  lua_pushnil(L);
  const int lc51 = lua_equal(L,-1,6);
  lua_pop(L,1);
  lua_pushboolean(L,lc51);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc52 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc52) {
    
    /* --ngx.log(ngx.ERR, "verify" .. rres.body);
     * return rres.body */
    lua_pushliteral(L,"body");
    lua_gettable(L,6);
    return 1;
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc50);
  assert(lua_gettop(L) == 7);
  
  /* --end
   * return nil */
  lua_pushnil(L);
  return 1;
  assert(lua_gettop(L) == 7);
}


/* name: _M.signature
 * function (content) */
static int lcf1__M_signature (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local params = {
   * 	   method     = "POST",
   * 	   ssl_verify = false ,
   * 	   body       = ""
   * 	} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"method");
  lua_pushliteral(L,"POST");
  lua_rawset(L,-3);
  lua_pushliteral(L,"ssl_verify");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  lua_pushliteral(L,"body");
  lua_pushliteral(L,"");
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 2);
  
  /* params.headers = {
   * 		["Content-Type"] =  "application/json"
   * 	} */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"Content-Type");
  lua_pushliteral(L,"application/json");
  lua_rawset(L,-3);
  lua_pushliteral(L,"headers");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 2);
  
  /* local pack = {
   * 		["source"] = content
   * 	} */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"source");
  lua_pushvalue(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 3);
  
  /* params.body= cjson.encode(pack) */
  lc_getupvalue(L,lua_upvalueindex(1),9,1);
  lua_pushliteral(L,"encode");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  lua_pushliteral(L,"body");
  lua_insert(L,-2);
  lua_settable(L,2);
  assert(lua_gettop(L) == 3);
  
  /* local auth_url   = _M.get_base_componet_path () .. "sign" */
  lc_getupvalue(L,lua_upvalueindex(1),3,7);
  lua_pushliteral(L,"get_base_componet_path");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushliteral(L,"sign");
  lua_concat(L,2);
  assert(lua_gettop(L) == 4);
  
  /* local httpd   	 = http.new() */
  lc_getupvalue(L,lua_upvalueindex(1),8,2);
  lua_pushliteral(L,"new");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  assert(lua_gettop(L) == 5);
  
  /* local rres, rerr = httpd:request_uri(auth_url, params) */
  lua_pushvalue(L,5);
  lua_pushliteral(L,"request_uri");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,4);
  lua_pushvalue(L,2);
  lua_call(L,3,2);
  assert(lua_gettop(L) == 7);
  
  /* if nil ~= rres then */
  enum { lc53 = 7 };
  lua_pushnil(L);
  const int lc54 = lua_equal(L,-1,6);
  lua_pop(L,1);
  lua_pushboolean(L,lc54);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc55 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc55) {
    
    /* return rres.body */
    lua_pushliteral(L,"body");
    lua_gettable(L,6);
    return 1;
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc53);
  assert(lua_gettop(L) == 7);
  
  /* ngx.log(ngx.ERR, "sign error::" .. rerr) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"log");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ERR");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"sign error::");
  lua_pushvalue(L,7);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 7);
  
  /* return nil */
  lua_pushnil(L);
  return 1;
  assert(lua_gettop(L) == 7);
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: _M.get_acc_from_aaa_gate
 * function (node, contentIds) */
static int lcf1__M_get_acc_from_aaa_gate (lua_State * L) {
  lua_checkstack(L,24);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local cache_ngx = ngx.shared.ngx_share_dict */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"shared");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ngx_share_dict");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* local cache     = cache_ngx:get(node.deviceID .. "aaa") */
  lua_pushvalue(L,3);
  lua_pushliteral(L,"get");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"deviceID");
  lua_gettable(L,1);
  lua_pushliteral(L,"aaa");
  lua_concat(L,2);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 4);
  
  /* if cache ~= nil then */
  enum { lc57 = 4 };
  lua_pushnil(L);
  const int lc58 = lua_equal(L,4,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc58);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc59 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc59) {
    
    /* return cache */
    lua_pushvalue(L,4);
    return 1;
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc57);
  assert(lua_gettop(L) == 4);
  
  /* local  d = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 5);
  
  /* d.type = "contentRightsRequest" */
  lua_pushliteral(L,"contentRightsRequest");
  lua_pushliteral(L,"type");
  lua_insert(L,-2);
  lua_settable(L,5);
  assert(lua_gettop(L) == 5);
  
  /* d.version =  "1.0" */
  lua_pushliteral(L,"1.0");
  lua_pushliteral(L,"version");
  lua_insert(L,-2);
  lua_settable(L,5);
  assert(lua_gettop(L) == 5);
  
  /* d.drmServerID          = _M.g_server_id */
  lc_getupvalue(L,lua_upvalueindex(1),4,7);
  lua_pushliteral(L,"g_server_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"drmServerID");
  lua_insert(L,-2);
  lua_settable(L,5);
  assert(lua_gettop(L) == 5);
  
  /* d.drmClientID          = node.deviceID */
  lua_pushliteral(L,"deviceID");
  lua_gettable(L,1);
  lua_pushliteral(L,"drmClientID");
  lua_insert(L,-2);
  lua_settable(L,5);
  assert(lua_gettop(L) == 5);
  
  /* local tmp = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 6);
  
  /* for i, v in ipairs(contentIds) do
   * internal: local f, s, var = explist */
  enum { lc60 = 6 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local i with idx 10
     * internal: local v with idx 11 */
    
    
    /* tmp[i] = v.contentID */
    lua_pushliteral(L,"contentID");
    lua_gettable(L,11);
    lua_pushvalue(L,10);
    lua_insert(L,-2);
    lua_settable(L,6);
    assert(lua_gettop(L) == 11);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,2);
  }
  lua_settop(L,lc60);
  assert(lua_gettop(L) == 6);
  
  /* d.contentIDs           = tmp */
  lua_pushvalue(L,6);
  lua_pushliteral(L,"contentIDs");
  lua_insert(L,-2);
  lua_settable(L,5);
  assert(lua_gettop(L) == 6);
  
  /* d.certificateChain     = _M.certificateChain */
  lc_getupvalue(L,lua_upvalueindex(1),4,7);
  lua_pushliteral(L,"certificateChain");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"certificateChain");
  lua_insert(L,-2);
  lua_settable(L,5);
  assert(lua_gettop(L) == 6);
  
  /* d.selectedAlgorithm    = _M.g_selectedAlgorithm */
  lc_getupvalue(L,lua_upvalueindex(1),4,7);
  lua_pushliteral(L,"g_selectedAlgorithm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"selectedAlgorithm");
  lua_insert(L,-2);
  lua_settable(L,5);
  assert(lua_gettop(L) == 6);
  
  /* d.nonce 			   = node.nonce */
  lua_pushliteral(L,"nonce");
  lua_gettable(L,1);
  lua_pushliteral(L,"nonce");
  lua_insert(L,-2);
  lua_settable(L,5);
  assert(lua_gettop(L) == 6);
  
  /* local str_req = cjson.encode(d) */
  lc_getupvalue(L,lua_upvalueindex(1),10,1);
  lua_pushliteral(L,"encode");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,5);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* local n_str   = isub(str_req,1,ilen(str_req)-1) */
  lc_getupvalue(L,lua_upvalueindex(1),7,4);
  lua_pushvalue(L,7);
  lua_pushnumber(L,1);
  lc_getupvalue(L,lua_upvalueindex(1),6,5);
  lua_pushvalue(L,7);
  lua_call(L,1,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 8);
  
  /* local sign    = n_str .. ",\"signature\":\"\"}" */
  lua_pushvalue(L,8);
  lua_pushliteral(L,",\"signature\":\"\"}");
  lua_concat(L,2);
  assert(lua_gettop(L) == 9);
  
  /* str_req = n_str .. ",\"signature\":\"".._M.signature(sign).."\"}" */
  lua_pushvalue(L,8);
  lua_pushliteral(L,",\"signature\":\"");
  lc_getupvalue(L,lua_upvalueindex(1),4,7);
  lua_pushliteral(L,"signature");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,9);
  lua_call(L,1,1);
  lua_pushliteral(L,"\"}");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_replace(L,7);
  assert(lua_gettop(L) == 9);
  
  /* ngx.log(ngx.ERR, "AAA_req" .. str_req) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"log");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ERR");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"AAA_req");
  lua_pushvalue(L,7);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 9);
  
  /* local params = {  
   * 	   method     = "POST",
   * 	   ssl_verify = false
   * 	} */
  lua_createtable(L,0,2);
  lua_pushliteral(L,"method");
  lua_pushliteral(L,"POST");
  lua_rawset(L,-3);
  lua_pushliteral(L,"ssl_verify");
  lua_pushboolean(L,0);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 10);
  
  /* params.headers = {} */
  lua_newtable(L);
  lua_pushliteral(L,"headers");
  lua_insert(L,-2);
  lua_settable(L,10);
  assert(lua_gettop(L) == 10);
  
  /* params.headers ["Content-Type"]  = "application/json" */
  lua_pushliteral(L,"application/json");
  lua_pushliteral(L,"headers");
  lua_gettable(L,10);
  lua_insert(L,-2);
  lua_pushliteral(L,"Content-Type");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 10);
  
  /* params.body= str_req */
  lua_pushvalue(L,7);
  lua_pushliteral(L,"body");
  lua_insert(L,-2);
  lua_settable(L,10);
  assert(lua_gettop(L) == 10);
  
  /* local auth_url   = _M.AAAGATE .. "get_rules" */
  lc_getupvalue(L,lua_upvalueindex(1),4,7);
  lua_pushliteral(L,"AAAGATE");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_rules");
  lua_concat(L,2);
  assert(lua_gettop(L) == 11);
  
  /* local httpd   	 = http.new() */
  lc_getupvalue(L,lua_upvalueindex(1),9,2);
  lua_pushliteral(L,"new");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  assert(lua_gettop(L) == 12);
  
  /* local rres, rerr = httpd:request_uri(auth_url, params) */
  lua_pushvalue(L,12);
  lua_pushliteral(L,"request_uri");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,11);
  lua_pushvalue(L,10);
  lua_call(L,3,2);
  assert(lua_gettop(L) == 14);
  
  /* if rres ~= nil then */
  enum { lc61 = 14 };
  lua_pushnil(L);
  const int lc62 = lua_equal(L,13,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc62);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc63 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc63) {
    
    /* if nil ~= rres.body then */
    enum { lc64 = 14 };
    lua_pushnil(L);
    lua_pushliteral(L,"body");
    lua_gettable(L,13);
    const int lc65 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc65);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc66 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc66) {
      
      /* ngx.log(ngx.ERR, "aaa-res=" .. rres.body) */
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"log");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ERR");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"aaa-res=");
      lua_pushliteral(L,"body");
      lua_gettable(L,13);
      lua_concat(L,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 14);
      
      /* --local value = cache_ngx:set(content.deviceID, rres.body, 1);  --10min
       * --local data  = cjson.decode(rres.body);
       * --if data.keyGateWayID ~= nil then
       * --ngx.ctx.serverid = data.keyGateWayID;
       * --end
       * --ngx.log(ngx.ERR , rres.body);
       * cache_ngx:set(node.deviceID .. "aaa", rres.body ,1) */
      lua_pushvalue(L,3);
      lua_pushliteral(L,"set");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"deviceID");
      lua_gettable(L,1);
      lua_pushliteral(L,"aaa");
      lua_concat(L,2);
      lua_pushliteral(L,"body");
      lua_gettable(L,13);
      lua_pushnumber(L,1);
      lua_call(L,4,0);
      assert(lua_gettop(L) == 14);
      
      /* return rres.body */
      lua_pushliteral(L,"body");
      lua_gettable(L,13);
      return 1;
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc64);
    assert(lua_gettop(L) == 14);
  }
  lua_settop(L,lc61);
  assert(lua_gettop(L) == 14);
  
  /* ngx.log(ngx.ERR, "err:500 aaa gate way" .. rerr) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"log");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ERR");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"err:500 aaa gate way");
  lua_pushvalue(L,14);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 14);
  
  /* --ngx.exit(500);
   * return "" */
  lua_pushliteral(L,"");
  return 1;
  assert(lua_gettop(L) == 14);
}


/* name: _M.get_ecek_from_key_gate
 * function (node, contentIds) */
static int lcf1__M_get_ecek_from_key_gate (lua_State * L) {
  lua_checkstack(L,20);
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local cache_ngx = ngx.shared.ngx_share_dict */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"shared");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ngx_share_dict");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* local cache     = cache_ngx:get(node.deviceID .. node.contentIDs[1] .. #node.contentIDs .. ".kgw") */
  lua_pushvalue(L,3);
  lua_pushliteral(L,"get");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"deviceID");
  lua_gettable(L,1);
  lua_pushliteral(L,"contentIDs");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"contentIDs");
  lua_gettable(L,1);
  const double lc67 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc67);
  lua_pushliteral(L,".kgw");
  lua_concat(L,2);
  lua_concat(L,2);
  lua_concat(L,2);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 4);
  
  /* -- if cache ~= nil then
   * -- 	return cache;
   * -- end
   * local  d = {
   * 		["type"]    =  "keyRequest",
   * 		["version"] =  "1.0" ,
   * 		["drmServerID"] = _M.g_server_id,
   * 		["contentIDs"]  = contentIds,
   * 		["certificateChain"] = _M.certificateChain,
   * 		["drmClientCertificate"] = node.certificateChain[1],
   * 		["selectedAlgorithm"]    = _M.g_selectedAlgorithm,
   * 		["nonce"] = node.nonce
   * 	} */
  lua_createtable(L,0,8);
  lua_pushliteral(L,"type");
  lua_pushliteral(L,"keyRequest");
  lua_rawset(L,-3);
  lua_pushliteral(L,"version");
  lua_pushliteral(L,"1.0");
  lua_rawset(L,-3);
  lua_pushliteral(L,"drmServerID");
  lc_getupvalue(L,lua_upvalueindex(1),4,7);
  lua_pushliteral(L,"g_server_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"contentIDs");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"certificateChain");
  lc_getupvalue(L,lua_upvalueindex(1),4,7);
  lua_pushliteral(L,"certificateChain");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drmClientCertificate");
  lua_pushliteral(L,"certificateChain");
  lua_gettable(L,1);
  lua_pushnumber(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"selectedAlgorithm");
  lc_getupvalue(L,lua_upvalueindex(1),4,7);
  lua_pushliteral(L,"g_selectedAlgorithm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"nonce");
  lua_pushliteral(L,"nonce");
  lua_gettable(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 5);
  
  /* -- d.type = "keyRequest";
   * -- d.version =  "1.0";
   * -- d.drmServerID          = _M.g_server_id;
   * -- d.contentIDs           = contentIds;
   * -- d.certificateChain     = _M.certificateChain;
   * -- d.drmClientCertificate = node.certificateChain[1];
   * -- d.selectedAlgorithm    = _M.g_selectedAlgorithm;
   * -- d.nonce 			   = node.nonce;
   * -------------------------------减少relloc的次数
   * local str_req = cjson.encode(d) */
  lc_getupvalue(L,lua_upvalueindex(1),10,1);
  lua_pushliteral(L,"encode");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,5);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 6);
  
  /* ngx.log(ngx.ERR, str_req) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"log");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ERR");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,6);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 6);
  
  /* local n_str   = isub(str_req,1,ilen(str_req)-1) */
  lc_getupvalue(L,lua_upvalueindex(1),7,4);
  lua_pushvalue(L,6);
  lua_pushnumber(L,1);
  lc_getupvalue(L,lua_upvalueindex(1),6,5);
  lua_pushvalue(L,6);
  lua_call(L,1,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 7);
  
  /* local sign    = n_str .. ",\"signature\":\"\"}" */
  lua_pushvalue(L,7);
  lua_pushliteral(L,",\"signature\":\"\"}");
  lua_concat(L,2);
  assert(lua_gettop(L) == 8);
  
  /* local __sign = csignature(sign) */
  lc_getupvalue(L,lua_upvalueindex(1),0,11);
  lua_pushvalue(L,8);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 9);
  
  /* if __sign == nil then */
  enum { lc68 = 9 };
  lua_pushnil(L);
  const int lc69 = lua_equal(L,9,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc69);
  const int lc70 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc70) {
    
    /* ngx.log(ngx.ERR, "\n\n[error] __sign error \n\n") */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ERR");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"\n\n[error] __sign error \n\n");
    lua_call(L,2,0);
    assert(lua_gettop(L) == 9);
    
    /* ngx.exit(500) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,500);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 9);
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L,lc68);
  assert(lua_gettop(L) == 9);
  
  /* str_req = gconcat({ n_str , ",\"signature\":\"", __sign, "\"}"}) */
  lc_getupvalue(L,lua_upvalueindex(1),5,6);
  lua_createtable(L,4,0);
  lua_pushvalue(L,7);
  lua_rawseti(L,-2,1);
  lua_pushliteral(L,",\"signature\":\"");
  lua_rawseti(L,-2,2);
  lua_pushvalue(L,9);
  lua_rawseti(L,-2,3);
  lua_pushliteral(L,"\"}");
  lua_rawseti(L,-2,4);
  lua_call(L,1,1);
  lua_replace(L,6);
  assert(lua_gettop(L) == 9);
  
  /* local str = _M.key_req_send (node, str_req) */
  lc_getupvalue(L,lua_upvalueindex(1),4,7);
  lua_pushliteral(L,"key_req_send");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,1);
  lua_pushvalue(L,6);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 10);
  
  /* -- ngx.log(ngx.ERR, "ecek" .. str);
   * return str */
  lua_pushvalue(L,10);
  return 1;
  assert(lua_gettop(L) == 10);
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: _M.get_content_id_from_req
 * function (node) */
static int lcf1__M_get_content_id_from_req (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local eax = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 2);
  
  /* if ngx.ctx.contentID ~= nil then */
  enum { lc72 = 2 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"contentID");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnil(L);
  const int lc73 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc73);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc74 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc74) {
    
    /* eax = ngx.ctx.contentID */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"contentID");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_replace(L,2);
    assert(lua_gettop(L) == 2);
  }
  else {
    
    /* else
     * eax = node.contentIDs */
    lua_pushliteral(L,"contentIDs");
    lua_gettable(L,1);
    lua_replace(L,2);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc72);
  assert(lua_gettop(L) == 2);
  
  /* local contents_ids = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 3);
  
  /* local time_curr = ngx.time() .. "" */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"time");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushliteral(L,"");
  lua_concat(L,2);
  assert(lua_gettop(L) == 4);
  
  /* local time_end  = (time_curr + NEXT_DAY_SEC ).. "" */
  lc_getupvalue(L,lua_upvalueindex(1),0,12);
  lc_add(L,4,-1);
  lua_remove(L,-2);
  lua_pushliteral(L,"");
  lua_concat(L,2);
  assert(lua_gettop(L) == 5);
  
  /* -- NEXT_DAY_SEC
   * for k, v in ipairs(eax) do
   * 		--if v ~= nil then
   * 			--防止realloc优化
   * internal: local f, s, var = explist */
  enum { lc75 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
  lua_pushvalue(L,2);
  lua_call(L,1,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local k with idx 9
     * internal: local v with idx 10 */
    
    
    /* --if v ~= nil then
     * --防止realloc优化
     * local oneContent = {
     * 				["contentID"] = "",
     * 				["startTime"] = "",
     * 				["endTime"]   = ""
     * 			} */
    lua_createtable(L,0,3);
    lua_pushliteral(L,"contentID");
    lua_pushliteral(L,"");
    lua_rawset(L,-3);
    lua_pushliteral(L,"startTime");
    lua_pushliteral(L,"");
    lua_rawset(L,-3);
    lua_pushliteral(L,"endTime");
    lua_pushliteral(L,"");
    lua_rawset(L,-3);
    assert(lua_gettop(L) == 11);
    
    /* oneContent.contentID = v */
    lua_pushvalue(L,10);
    lua_pushliteral(L,"contentID");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 11);
    
    /* oneContent.startTime = time_curr */
    lua_pushvalue(L,4);
    lua_pushliteral(L,"startTime");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 11);
    
    /* oneContent.endTime   = time_end */
    lua_pushvalue(L,5);
    lua_pushliteral(L,"endTime");
    lua_insert(L,-2);
    lua_settable(L,11);
    assert(lua_gettop(L) == 11);
    
    /* contents_ids[k]      = oneContent */
    lua_pushvalue(L,11);
    lua_pushvalue(L,9);
    lua_insert(L,-2);
    lua_settable(L,3);
    assert(lua_gettop(L) == 11);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc75);
  assert(lua_gettop(L) == 5);
  
  /* return contents_ids */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 5);
}


/* name: _M.check_time_correct
 * function (check_time) */
static int lcf1__M_check_time_correct (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* return true */
  lua_pushboolean(L,1);
  return 1;
  assert(lua_gettop(L) == 1);
}


/* name: _M.get_share_dict_data
 * function (key) */
static int lcf1__M_get_share_dict_data (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* return  cache_ngx:get(key) */
  const int lc77 = lua_gettop(L);
  lc_getupvalue(L,lua_upvalueindex(1),0,13);
  lua_pushliteral(L,"get");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,2,LUA_MULTRET);
  return (lua_gettop(L) - lc77);
  assert(lua_gettop(L) == 1);
}


/* name: _M.default_response_print
 * function () */
static int lcf1__M_default_response_print (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* if not ngx.ctx.nonce then */
  enum { lc81 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"nonce");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc82 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc82) {
    
    /* ngx.ctx.nonce     = "" */
    lua_pushliteral(L,"");
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"nonce");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L,lc81);
  assert(lua_gettop(L) == 0);
  
  /* if not ngx.ctx.status then */
  enum { lc83 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"status");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc84 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc84) {
    
    /* ngx.ctx.status   = "malformedRequest" */
    lua_pushliteral(L,"malformedRequest");
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"status");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L,lc83);
  assert(lua_gettop(L) == 0);
  
  /* if not ngx.ctx.deviceID then */
  enum { lc85 = 0 };
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"deviceID");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc86 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc86) {
    
    /* ngx.ctx.deviceID = "" */
    lua_pushliteral(L,"");
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"deviceID");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L,lc85);
  assert(lua_gettop(L) == 0);
  
  /* -----relloc 优化
   * local result = {0,0,0,0,0,0,0,0,0,0,0} */
  lua_createtable(L,11,0);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,6);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,7);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,8);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,9);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,10);
  lua_pushnumber(L,0);
  lua_rawseti(L,-2,11);
  assert(lua_gettop(L) == 1);
  
  /* result[1] = '{"type":"licenseResponse","version":"2.0","status":"' */
  lua_pushliteral(L,"{\"type\":\"licenseResponse\",\"version\":\"2.0\",\"status\":\"");
  lua_pushnumber(L,1);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* result[2] = ngx.ctx.status */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"status");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,2);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* result[3] = '","selectedAlgorithm":"KMSProfile1","responseTime":"' */
  lua_pushliteral(L,"\",\"selectedAlgorithm\":\"KMSProfile1\",\"responseTime\":\"");
  lua_pushnumber(L,3);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* result[4] = ngx.time() */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"time");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushnumber(L,4);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* result[5] = '","deviceID":"' */
  lua_pushliteral(L,"\",\"deviceID\":\"");
  lua_pushnumber(L,5);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* result[6] = ngx.ctx.deviceID */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"deviceID");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,6);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* result[7] = '","drmServerID":"' */
  lua_pushliteral(L,"\",\"drmServerID\":\"");
  lua_pushnumber(L,7);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* result[8] = _M.g_server_id */
  lc_getupvalue(L,lua_upvalueindex(1),9,7);
  lua_pushliteral(L,"g_server_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,8);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* result[9] =  '","nonce":"' */
  lua_pushliteral(L,"\",\"nonce\":\"");
  lua_pushnumber(L,9);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* result[10] = ngx.ctx.nonce */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"nonce");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,10);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* result[11] ='","protectedLicenses":[],"certificateChain":[],"signature":""}' */
  lua_pushliteral(L,"\",\"protectedLicenses\":[],\"certificateChain\":[],\"signature\":\"\"}");
  lua_pushnumber(L,11);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 1);
  
  /* --local str_req = test ;-- cjson.encode(res) ;
   * --local str_req = cjson.encode(res) 
   * local  result_str = gconcat(result) */
  lc_getupvalue(L,lua_upvalueindex(1),10,6);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 2);
  
  /* ngx.log(ngx.ERR, "resp::err" .. result_str) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"log");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ERR");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"resp::err");
  lua_pushvalue(L,2);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 2);
  
  /* ngx.say(result_str) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"say");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 2);
  
  /* ngx.exit(200) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"exit");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,200);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 2);
  return 0;
}


/* name: _M.crl_check
 * function (deviceId) */
static int lcf1__M_crl_check (lua_State * L) {
  lua_checkstack(L,24);
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local key = "suma_crl_" ..  deviceId */
  lua_pushliteral(L,"suma_crl_");
  lua_pushvalue(L,1);
  lua_concat(L,2);
  assert(lua_gettop(L) == 2);
  
  /* local redis = require("suma_apollo_redis") */
  lua_getfield(L,LUA_ENVIRONINDEX,"require");
  lua_pushliteral(L,"suma_apollo_redis");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* local red   = redis:new() */
  lua_pushvalue(L,3);
  lua_pushliteral(L,"new");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 4);
  
  /* local ok, err = red:connect(_M.REDIS_HOST,  6379) */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"connect");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),9,7);
  lua_pushliteral(L,"REDIS_HOST");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,6379);
  lua_call(L,3,2);
  assert(lua_gettop(L) == 6);
  
  /* red:auth("redis") */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"auth");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"redis");
  lua_call(L,2,0);
  assert(lua_gettop(L) == 6);
  
  /* if not ok then */
  enum { lc87 = 6 };
  lua_pushboolean(L,!(lua_toboolean(L,5)));
  const int lc88 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc88) {
    
    /* ---连接失败正常访问
     * ngx.log(ngx.ERR, "connect to redis error : " , err) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ERR");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"connect to redis error : ");
    lua_pushvalue(L,6);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 6);
    
    /* red:close() */
    lua_pushvalue(L,4);
    lua_pushliteral(L,"close");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 6);
    
    /* return ; */
    return 0;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc87);
  assert(lua_gettop(L) == 6);
  
  /* ----请求redis
   * local res = red:get(key) */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"get");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 7);
  
  /* red:close() */
  lua_pushvalue(L,4);
  lua_pushliteral(L,"close");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 7);
  
  /* -- ngx.log(ngx.ERR, "cc=" .. tostring(res))
   * if tostring(res) == "userdata: NULL" then */
  enum { lc89 = 7 };
  lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
  lua_pushvalue(L,7);
  lua_call(L,1,1);
  lua_pushliteral(L,"userdata: NULL");
  const int lc90 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc90);
  const int lc91 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc91) {
    
    /* --代表 CRL 服务过期清空
     * ---开始请求
     * -- ngx.log(ngx.ERR, "gogogo");
     * local params = {
     * 		   method     = "POST",
     * 		   ssl_verify = false
     * 		} */
    lua_createtable(L,0,2);
    lua_pushliteral(L,"method");
    lua_pushliteral(L,"POST");
    lua_rawset(L,-3);
    lua_pushliteral(L,"ssl_verify");
    lua_pushboolean(L,0);
    lua_rawset(L,-3);
    assert(lua_gettop(L) == 8);
    
    /* params.headers = {} */
    lua_newtable(L);
    lua_pushliteral(L,"headers");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 8);
    
    /* params.headers ["Content-Type"]  = "application/json" */
    lua_pushliteral(L,"application/json");
    lua_pushliteral(L,"headers");
    lua_gettable(L,8);
    lua_insert(L,-2);
    lua_pushliteral(L,"Content-Type");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 8);
    
    /* local pack = {} */
    lua_newtable(L);
    assert(lua_gettop(L) == 9);
    
    /* --content = isub (content,1,ilen(content)-2);
     * --content = string.gsub(content, "%\\%/", "%/");
     * pack.deviceID= deviceId */
    lua_pushvalue(L,1);
    lua_pushliteral(L,"deviceID");
    lua_insert(L,-2);
    lua_settable(L,9);
    assert(lua_gettop(L) == 9);
    
    /* pack.cert    = ngx.ctx.cert */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"cert");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"cert");
    lua_insert(L,-2);
    lua_settable(L,9);
    assert(lua_gettop(L) == 9);
    
    /* params.body= cjson.encode(pack) */
    lc_getupvalue(L,lua_upvalueindex(1),15,1);
    lua_pushliteral(L,"encode");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,9);
    lua_call(L,1,1);
    lua_pushliteral(L,"body");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 9);
    
    /* local auth_url   = _M.CRL_HOST .. "verify_crl" */
    lc_getupvalue(L,lua_upvalueindex(1),9,7);
    lua_pushliteral(L,"CRL_HOST");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"verify_crl");
    lua_concat(L,2);
    assert(lua_gettop(L) == 10);
    
    /* local httpd   	 = http.new() */
    lc_getupvalue(L,lua_upvalueindex(1),14,2);
    lua_pushliteral(L,"new");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    assert(lua_gettop(L) == 11);
    
    /* local rres, rerr = httpd:request_uri(auth_url, params) */
    lua_pushvalue(L,11);
    lua_pushliteral(L,"request_uri");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,10);
    lua_pushvalue(L,8);
    lua_call(L,3,2);
    assert(lua_gettop(L) == 13);
    
    /* --if rres ~= nil then
     * if rerr then */
    enum { lc92 = 13 };
    if (lua_toboolean(L,13)) {
      
      /* ngx.log(ngx.ERR, rerr) */
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"log");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ERR");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,13);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 13);
    }
    lua_settop(L,lc92);
    assert(lua_gettop(L) == 13);
    
    /* if nil ~= rres then */
    enum { lc93 = 13 };
    lua_pushnil(L);
    const int lc94 = lua_equal(L,-1,12);
    lua_pop(L,1);
    lua_pushboolean(L,lc94);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc95 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc95) {
      
      /* ngx.log(ngx.ERR, "crl =" .. rres.body) */
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"log");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ERR");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"crl =");
      lua_pushliteral(L,"body");
      lua_gettable(L,12);
      lua_concat(L,2);
      lua_call(L,2,0);
      assert(lua_gettop(L) == 13);
      
      /* local data = cjson.decode(rres.body) */
      lc_getupvalue(L,lua_upvalueindex(1),15,1);
      lua_pushliteral(L,"decode");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"body");
      lua_gettable(L,12);
      lua_call(L,1,1);
      assert(lua_gettop(L) == 14);
      
      /* if data.code == 2 then */
      enum { lc96 = 14 };
      lua_pushliteral(L,"code");
      lua_gettable(L,14);
      lua_pushnumber(L,2);
      const int lc97 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc97);
      const int lc98 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc98) {
        
        /* ngx.log(ngx.ERR, "crl result2 block") */
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"log");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"ERR");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"crl result2 block");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 14);
        
        /* -- return rres.body
         * if ngx.ctx.status == "success" then */
        enum { lc99 = 14 };
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"ctx");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"status");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"success");
        const int lc100 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc100);
        const int lc101 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc101) {
          
          /* ngx.ctx.status = "abort" */
          lua_pushliteral(L,"abort");
          lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
          lua_pushliteral(L,"ctx");
          lua_gettable(L,-2);
          lua_remove(L,-2);
          lua_insert(L,-2);
          lua_pushliteral(L,"status");
          lua_insert(L,-2);
          lua_settable(L,-3);
          lua_pop(L,1);
          assert(lua_gettop(L) == 14);
        }
        lua_settop(L,lc99);
        assert(lua_gettop(L) == 14);
        
        /* _M.default_response_print() */
        lc_getupvalue(L,lua_upvalueindex(1),9,7);
        lua_pushliteral(L,"default_response_print");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_call(L,0,0);
        assert(lua_gettop(L) == 14);
        
        /* ngx.log(ngx.ERR, "crl block request") */
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"log");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"ERR");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"crl block request");
        lua_call(L,2,0);
        assert(lua_gettop(L) == 14);
        
        /* ngx.exit(200) */
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"exit");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushnumber(L,200);
        lua_call(L,1,0);
        assert(lua_gettop(L) == 14);
        
        /* return ; */
        return 0;
        assert(lua_gettop(L) == 14);
      }
      lua_settop(L,lc96);
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc93);
    assert(lua_gettop(L) == 13);
    
    /* --end
     * -- return nil;
     * return; */
    return 0;
    assert(lua_gettop(L) == 13);
  }
  lua_settop(L,lc89);
  assert(lua_gettop(L) == 7);
  
  /* if res == 2 then */
  enum { lc102 = 7 };
  lua_pushnumber(L,2);
  const int lc103 = lua_equal(L,7,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc103);
  const int lc104 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc104) {
    
    /* if ngx.ctx.status == "success" then */
    enum { lc105 = 7 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"status");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"success");
    const int lc106 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc106);
    const int lc107 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc107) {
      
      /* ngx.ctx.status = "abort" */
      lua_pushliteral(L,"abort");
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ctx");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"status");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 7);
    }
    lua_settop(L,lc105);
    assert(lua_gettop(L) == 7);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lua_upvalueindex(1),9,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 7);
    
    /* ngx.log(ngx.ERR, "crl block request") */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ERR");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"crl block request");
    lua_call(L,2,0);
    assert(lua_gettop(L) == 7);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 7);
    
    /* return ; */
    return 0;
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc102);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* name: _M.ocsp_get
 * function () */
static int lcf1__M_ocsp_get (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* local key = "suma_ocsp_ri" */
  lua_pushliteral(L,"suma_ocsp_ri");
  assert(lua_gettop(L) == 1);
  
  /* local exists = func_get_share_dict_data(key) */
  lc_getupvalue(L,lua_upvalueindex(1),2,14);
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 2);
  
  /* if exists ~= nil then */
  enum { lc108 = 2 };
  lua_pushnil(L);
  const int lc109 = lua_equal(L,2,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc109);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc110 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc110) {
    
    /* return exists */
    lua_pushvalue(L,2);
    return 1;
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc108);
  assert(lua_gettop(L) == 2);
  
  /* local cache_ngx   = ngx.shared.ngx_share_dict */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"shared");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ngx_share_dict");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* local newval, err = cache_ngx:incr(key .. ".lock",1, 0, 1) */
  lua_pushvalue(L,3);
  lua_pushliteral(L,"incr");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,1);
  lua_pushliteral(L,".lock");
  lua_concat(L,2);
  lua_pushnumber(L,1);
  lua_pushnumber(L,0);
  lua_pushnumber(L,1);
  lua_call(L,5,2);
  assert(lua_gettop(L) == 5);
  
  /* --- 自悬锁
   * if tonumber(newval) ~= 1 then */
  enum { lc111 = 5 };
  lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
  lua_pushvalue(L,4);
  lua_call(L,1,1);
  lua_pushnumber(L,1);
  const int lc112 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc112);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc113 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc113) {
    
    /* ngx.sleep(0.1) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"sleep");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,0.1);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 5);
    
    /* --- sleep 100ms timeout 
     * return func_get_share_dict_data(key) */
    const int lc114 = lua_gettop(L);
    lc_getupvalue(L,lua_upvalueindex(1),2,14);
    lua_pushvalue(L,1);
    lua_call(L,1,LUA_MULTRET);
    return (lua_gettop(L) - lc114);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc111);
  assert(lua_gettop(L) == 5);
  
  /* local redis = require("suma_apollo_redis") */
  lua_getfield(L,LUA_ENVIRONINDEX,"require");
  lua_pushliteral(L,"suma_apollo_redis");
  lua_call(L,1,1);
  assert(lua_gettop(L) == 6);
  
  /* local red   = redis:new() */
  lua_pushvalue(L,6);
  lua_pushliteral(L,"new");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* local ok, err = red:connect(_M.REDIS_HOST,  6379) */
  lua_pushvalue(L,7);
  lua_pushliteral(L,"connect");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),9,7);
  lua_pushliteral(L,"REDIS_HOST");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,6379);
  lua_call(L,3,2);
  assert(lua_gettop(L) == 9);
  
  /* red:auth("redis") */
  lua_pushvalue(L,7);
  lua_pushliteral(L,"auth");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"redis");
  lua_call(L,2,0);
  assert(lua_gettop(L) == 9);
  
  /* if not ok then */
  enum { lc115 = 9 };
  lua_pushboolean(L,!(lua_toboolean(L,8)));
  const int lc116 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc116) {
    
    /* ngx.log(ngx.ERR, "connect to redis error : " , err) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ERR");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"connect to redis error : ");
    lua_pushvalue(L,9);
    lua_call(L,3,0);
    assert(lua_gettop(L) == 9);
    
    /* red:close() */
    lua_pushvalue(L,7);
    lua_pushliteral(L,"close");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 9);
    
    /* return "" */
    lua_pushliteral(L,"");
    return 1;
    assert(lua_gettop(L) == 9);
  }
  lua_settop(L,lc115);
  assert(lua_gettop(L) == 9);
  
  /* ----请求redis
   * local res = red:get(key) */
  lua_pushvalue(L,7);
  lua_pushliteral(L,"get");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,1);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 10);
  
  /* red:close() */
  lua_pushvalue(L,7);
  lua_pushliteral(L,"close");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 10);
  
  /* if res ~= nil then */
  enum { lc117 = 10 };
  lua_pushnil(L);
  const int lc118 = lua_equal(L,10,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc118);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc119 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc119) {
    
    /* local cache_ngx = ngx.shared.ngx_share_dict */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"shared");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"ngx_share_dict");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 11);
    
    /* local value     = cache_ngx:set(key, res, 300) */
    lua_pushvalue(L,11);
    lua_pushliteral(L,"set");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,10);
    lua_pushnumber(L,300);
    lua_call(L,4,1);
    assert(lua_gettop(L) == 12);
    
    /* return res */
    lua_pushvalue(L,10);
    return 1;
    assert(lua_gettop(L) == 12);
  }
  lua_settop(L,lc117);
  assert(lua_gettop(L) == 10);
  
  /* return "" */
  lua_pushliteral(L,"");
  return 1;
  assert(lua_gettop(L) == 10);
}


/* function (param) */
static int lcf128 (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* ---china drm
   * ngx.log(ngx.ERR, "china drm rrotate") */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"log");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ERR");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"china drm rrotate");
  lua_call(L,2,0);
  assert(lua_gettop(L) == 1);
  
  /* if param.contentID ~= nil then */
  enum { lc121 = 1 };
  lua_pushliteral(L,"contentID");
  lua_gettable(L,1);
  lua_pushnil(L);
  const int lc122 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc122);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc123 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc123) {
    
    /* if ngx.ctx.contentID == nil then */
    enum { lc124 = 1 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"contentID");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnil(L);
    const int lc125 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc125);
    const int lc126 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc126) {
      
      /* ngx.ctx.contentID = {} */
      lua_newtable(L);
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ctx");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"contentID");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 1);
    }
    lua_settop(L,lc124);
    assert(lua_gettop(L) == 1);
    
    /* ngx.ctx.contentID[#ngx.ctx.contentID + 1] = param.contentID */
    lua_pushliteral(L,"contentID");
    lua_gettable(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"contentID");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"contentID");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const double lc127 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc127);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 1);
    
    /* ngx.log(ngx.ERR, "add contentID=" .. param.contentID) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ERR");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"add contentID=");
    lua_pushliteral(L,"contentID");
    lua_gettable(L,1);
    lua_concat(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 1);
    
    /* return true */
    lua_pushboolean(L,1);
    return 1;
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc121);
  assert(lua_gettop(L) == 1);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 1);
}


/* name: split
 * function(szFullString, szSeparator) */
static int lcf1_split (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local nFindStartIndex = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 3);
  
  /* local nSplitIndex = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 4);
  
  /* local nSplitArray = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 5);
  
  /* while true do */
  enum { lc129 = 5 };
  while (1) {
    lua_pushboolean(L,1);
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* local nFindLastIndex = string.find(szFullString, szSeparator, nFindStartIndex) */
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,2);
    lua_pushvalue(L,3);
    lua_call(L,3,1);
    assert(lua_gettop(L) == 6);
    
    /* if not nFindLastIndex then */
    enum { lc130 = 6 };
    lua_pushboolean(L,!(lua_toboolean(L,6)));
    const int lc131 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc131) {
      
      /* nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, string.len(szFullString)) */
      lua_getfield(L,LUA_ENVIRONINDEX,"string");
      lua_pushliteral(L,"sub");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      const int lc132 = lua_gettop(L);
      lua_pushvalue(L,1);
      lua_pushvalue(L,3);
      lua_getfield(L,LUA_ENVIRONINDEX,"string");
      lua_pushliteral(L,"len");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_call(L,1,LUA_MULTRET);
      lua_call(L,(lua_gettop(L) - lc132),1);
      lua_pushvalue(L,4);
      lua_insert(L,-2);
      lua_settable(L,5);
      assert(lua_gettop(L) == 6);
      
      /* break */
      break;
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc130);
    assert(lua_gettop(L) == 6);
    
    /* nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, nFindLastIndex - 1) */
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"sub");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,3);
    lua_pushnumber(L,1);
    lc_sub(L,6,-1);
    lua_remove(L,-2);
    lua_call(L,3,1);
    lua_pushvalue(L,4);
    lua_insert(L,-2);
    lua_settable(L,5);
    assert(lua_gettop(L) == 6);
    
    /* nFindStartIndex = nFindLastIndex + string.len(szSeparator) */
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"len");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,2);
    lua_call(L,1,1);
    lc_add(L,6,-1);
    lua_remove(L,-2);
    lua_replace(L,3);
    assert(lua_gettop(L) == 6);
    
    /* nSplitIndex = nSplitIndex + 1 */
    lua_pushnumber(L,1);
    lc_add(L,4,-1);
    lua_remove(L,-2);
    lua_replace(L,4);
    assert(lua_gettop(L) == 6);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
  }
  lua_settop(L,lc129);
  assert(lua_gettop(L) == 5);
  
  /* return nSplitArray */
  lua_pushvalue(L,5);
  return 1;
  assert(lua_gettop(L) == 5);
}


static void lc_setupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawseti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while(--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_insert(L,-2);
    lua_rawseti(L,-2,varid);
    lua_pop(L,1);
  }
}


/* function () */
static int lcf162 (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* node = c_decode(pssh_data) */
  lc_getupvalue(L,lua_upvalueindex(1),16,3);
  lc_getupvalue(L,lua_upvalueindex(1),1,18);
  lua_call(L,1,1);
  lc_setupvalue(L,lua_upvalueindex(1),0,19);
  assert(lua_gettop(L) == 0);
  return 0;
}


/* name: _M.pssh_check
 * function (contentId) */
static int lcf1__M_pssh_check (lua_State * L) {
  lua_checkstack(L,22);
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* local dd 	   = contentId */
  lua_pushvalue(L,1);
  assert(lua_gettop(L) == 2);
  
  /* local byte_xor = string.byte */
  lua_getfield(L,LUA_ENVIRONINDEX,"string");
  lua_pushliteral(L,"byte");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* local obj      = ngx.decode_base64(dd) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"decode_base64");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 4);
  
  /* local is_m3u8  = string.char(byte_xor(obj,1,8)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"string");
  lua_pushliteral(L,"char");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc133 = lua_gettop(L);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_pushnumber(L,1);
  lua_pushnumber(L,8);
  lua_call(L,3,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc133),1);
  assert(lua_gettop(L) == 5);
  
  /* if "#EXT-X-K" ==  is_m3u8 then */
  enum { lc134 = 5 };
  lua_pushliteral(L,"#EXT-X-K");
  const int lc135 = lua_equal(L,-1,5);
  lua_pop(L,1);
  lua_pushboolean(L,lc135);
  const int lc136 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc136) {
    
    /* ngx.log(ngx.ERR, " m3u8 => mp4dash") */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ERR");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L," m3u8 => mp4dash");
    lua_call(L,2,0);
    assert(lua_gettop(L) == 5);
    
    /* local test2 = split (obj, ",") */
    lua_getfield(L,LUA_ENVIRONINDEX,"split");
    lua_pushvalue(L,4);
    lua_pushliteral(L,",");
    lua_call(L,2,1);
    assert(lua_gettop(L) == 6);
    
    /* local look_up_next = false */
    lua_pushboolean(L,0);
    assert(lua_gettop(L) == 7);
    
    /* for i, v in ipairs(test2) do
     * internal: local f, s, var = explist */
    enum { lc137 = 7 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
    lua_pushvalue(L,6);
    lua_call(L,1,3);
    while (1) {
      
      /* internal: local var_1, ..., var_n = f(s, var)
       *           if var_1 == nil then break end
       *           var = var_1 */
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_pushvalue(L,-3);
      lua_call(L,2,2);
      if (lua_isnil(L,-2)) {
        break;
      }
      lua_pushvalue(L,-2);
      lua_replace(L,-4);
      
      /* internal: local i with idx 11
       * internal: local v with idx 12 */
      
      
      /* if look_up_next then */
      enum { lc138 = 12 };
      if (lua_toboolean(L,7)) {
        
        /* ngx.log(ngx.ERR, "pssh data=:" .. v) */
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"log");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"ERR");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushliteral(L,"pssh data=:");
        lua_pushvalue(L,12);
        lua_concat(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 12);
        
        /* obj = ngx.decode_base64(string.sub(v, 1, #v-1)) */
        lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
        lua_pushliteral(L,"decode_base64");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc139 = lua_gettop(L);
        lua_getfield(L,LUA_ENVIRONINDEX,"string");
        lua_pushliteral(L,"sub");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        lua_pushvalue(L,12);
        lua_pushnumber(L,1);
        const double lc140 = lua_objlen(L,12);
        lua_pushnumber(L,lc140);
        lua_pushnumber(L,1);
        lc_sub(L,-2,-1);
        lua_remove(L,-2);
        lua_remove(L,-2);
        lua_call(L,3,LUA_MULTRET);
        lua_call(L,(lua_gettop(L) - lc139),1);
        lua_replace(L,4);
        assert(lua_gettop(L) == 12);
        
        /* look_up_next = false */
        lua_pushboolean(L,0);
        lua_replace(L,7);
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc138);
      assert(lua_gettop(L) == 12);
      
      /* if v == 'URI="data:text/plain;base64' then */
      enum { lc141 = 12 };
      lua_pushliteral(L,"URI=\"data:text/plain;base64");
      const int lc142 = lua_equal(L,12,-1);
      lua_pop(L,1);
      lua_pushboolean(L,lc142);
      const int lc143 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc143) {
        
        /* look_up_next = true */
        lua_pushboolean(L,1);
        lua_replace(L,7);
        assert(lua_gettop(L) == 12);
      }
      lua_settop(L,lc141);
      assert(lua_gettop(L) == 12);
      
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
    }
    lua_settop(L,lc137);
    assert(lua_gettop(L) == 7);
    
    /* if obj == nil then */
    enum { lc144 = 7 };
    lua_pushnil(L);
    const int lc145 = lua_equal(L,4,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc145);
    const int lc146 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc146) {
      
      /* return false */
      lua_pushboolean(L,0);
      return 1;
      assert(lua_gettop(L) == 7);
    }
    lua_settop(L,lc144);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc134);
  assert(lua_gettop(L) == 5);
  
  /* -- if (string.byte(obj, 33, 34) == 0x7b) and -- {
   * --    (string.byte(obj, tail - 1 , tail) == 0x7d) then -- }
   * -- 	-- ngx.log(ngx.ERR, "is a validate JSON");
   * -- else
   * -- 	return false;
   * -- end
   * -- ngx.log(ngx.ERR , string.byte(obj,1,#obj));
   * --    ngx.log(ngx.ERR, string.byte(obj,1,4));      -- Size 4字节
   * --    ngx.log(ngx.ERR, string.byte(obj,5,8));      -- Type 4字节 0x70 73 73 68
   * --    ngx.log(ngx.ERR, string.byte(obj,9,10));     -- version 1字节
   * --    ngx.log(ngx.ERR, string.byte(obj,11,12));    -- Flags 3字节
   * --    ngx.log(ngx.ERR, string.byte(obj,13,28));    -- SystemId 16字节
   * -- ngx.log(ngx.ERR, string.byte(obj,29,32));    -- dataSize 4字节
   * --类型不对
   * local  sType   = string.char(byte_xor(obj,5,8)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"string");
  lua_pushliteral(L,"char");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc147 = lua_gettop(L);
  lua_pushvalue(L,3);
  lua_pushvalue(L,4);
  lua_pushnumber(L,5);
  lua_pushnumber(L,8);
  lua_call(L,3,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc147),1);
  assert(lua_gettop(L) == 6);
  
  /* -- Type 4字节 0x70 73 73 68
   * -- ngx.log(ngx.ERR, "pssh = " .. sType);
   * if sType ~= "pssh" then */
  enum { lc148 = 6 };
  lua_pushliteral(L,"pssh");
  const int lc149 = lua_equal(L,6,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc149);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc150 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc150) {
    
    /* return false */
    lua_pushboolean(L,0);
    return 1;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc148);
  assert(lua_gettop(L) == 6);
  
  /* local tail = #obj */
  const double lc151 = lua_objlen(L,4);
  lua_pushnumber(L,lc151);
  assert(lua_gettop(L) == 7);
  
  /* ----因为截取的是指针，我们必须把指针转换成字符串
   * local buffer = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1} */
  lua_createtable(L,16,0);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,1);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,2);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,3);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,4);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,5);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,6);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,7);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,8);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,9);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,10);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,11);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,12);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,13);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,14);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,15);
  lua_pushnumber(L,1);
  lua_rawseti(L,-2,16);
  assert(lua_gettop(L) == 8);
  
  /* for i=1,16,1 do */
  lua_pushnumber(L,1);
  lua_pushnumber(L,16);
  lua_pushnumber(L,1);
  if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc152_var = lua_tonumber(L,-3);
  const double lc153_limit = lua_tonumber(L,-2);
  const double lc154_step = lua_tonumber(L,-1);
  lua_pop(L,3);
  enum { lc155 = 8 };
  while ((((lc154_step > 0) && (lc152_var <= lc153_limit)) || ((lc154_step <= 0) && (lc152_var >= lc153_limit)))) {
    
    /* internal: local i at index 9 */
    lua_pushnumber(L,lc152_var);
    
    /* buffer [i] = byte_xor(obj,i+12, i+13) */
    lua_pushvalue(L,3);
    lua_pushvalue(L,4);
    lua_pushnumber(L,12);
    lc_add(L,9,-1);
    lua_remove(L,-2);
    lua_pushnumber(L,13);
    lc_add(L,9,-1);
    lua_remove(L,-2);
    lua_call(L,3,1);
    lua_pushvalue(L,9);
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 9);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc152_var += lc154_step;
  }
  lua_settop(L,lc155);
  assert(lua_gettop(L) == 8);
  
  /* local system_id = gconcat(buffer) */
  lc_getupvalue(L,lua_upvalueindex(1),11,6);
  lua_pushvalue(L,8);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 9);
  
  /* -- ngx.log(ngx.ERR, "system_id=" .. system_id);
   * ----如果不在drm列表内说明没有注册的DRM ID
   * if _M.DRM_SYSTEM_ID[system_id] ~= nil then */
  enum { lc156 = 9 };
  lc_getupvalue(L,lua_upvalueindex(1),10,7);
  lua_pushliteral(L,"DRM_SYSTEM_ID");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,9);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnil(L);
  const int lc157 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc157);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc158 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc158) {
    
    /* local pssh_data = string.char(byte_xor(obj,33,tail)) */
    lc_newclosuretable(L,lua_upvalueindex(1));
    enum { lc159 = 10 };
    assert((lua_gettop(L) == lc159));
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"char");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const int lc160 = lua_gettop(L);
    lua_pushvalue(L,3);
    lua_pushvalue(L,4);
    lua_pushnumber(L,33);
    lua_pushvalue(L,7);
    lua_call(L,3,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc160),1);
    lua_rawseti(L,lc159,18);
    assert(lua_gettop(L) == 10);
    
    /* local node = nil */
    lc_newclosuretable(L,lc159);
    enum { lc161 = 11 };
    assert((lua_gettop(L) == lc161));
    lua_pushnil(L);
    lua_rawseti(L,lc161,19);
    assert(lua_gettop(L) == 11);
    
    /* -- ngx.log(ngx.ERR, pssh_data)
     * pcall(function ()
     * 			node = c_decode(pssh_data);
     * 		end) */
    lua_getfield(L,LUA_ENVIRONINDEX,"pcall");
    lua_pushvalue(L,lc161);
    lua_pushcclosure(L,lcf162,1);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 11);
    
    /* -- ngx.log(ngx.ERR, "node=" .. cjson.encode(node));
     * if (node ~= nil) then */
    enum { lc163 = 11 };
    lc_getupvalue(L,lc161,0,19);
    lua_pushnil(L);
    const int lc164 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc164);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc165 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc165) {
      
      /* return _M.DRM_SYSTEM_ID[system_id] (node) */
      const int lc166 = lua_gettop(L);
      lc_getupvalue(L,lc161,12,7);
      lua_pushliteral(L,"DRM_SYSTEM_ID");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,9);
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lc_getupvalue(L,lc161,0,19);
      lua_call(L,1,LUA_MULTRET);
      return (lua_gettop(L) - lc166);
      assert(lua_gettop(L) == 11);
    }
    lua_settop(L,lc163);
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc156);
  assert(lua_gettop(L) == 9);
  
  /* return false */
  lua_pushboolean(L,0);
  return 1;
  assert(lua_gettop(L) == 9);
}


/* function () */
static int lcf180 (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* node = c_decode(body_str) */
  lc_getupvalue(L,lua_upvalueindex(1),16,3);
  lc_getupvalue(L,lua_upvalueindex(1),1,20);
  lua_call(L,1,1);
  lc_setupvalue(L,lua_upvalueindex(1),0,21);
  assert(lua_gettop(L) == 0);
  return 0;
}


/* name: _M.handle
 * function () */
static int lcf1__M_handle (lua_State * L) {
  lua_checkstack(L,29);
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* -- ngx.exit(200);
   * -- local args = ngx.req.get_uri_args();
   * ---测试字段
   * -- if args and args.test ~= nil then
   * -- 	ngx.ctx.test = args.test;
   * -- end
   * ngx.ctx.status = "success" */
  lua_pushliteral(L,"success");
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"status");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 0);
  
  /* if _M.g_server_id == nil then */
  enum { lc167 = 0 };
  lc_getupvalue(L,lua_upvalueindex(1),10,7);
  lua_pushliteral(L,"g_server_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnil(L);
  const int lc168 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc168);
  const int lc169 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc169) {
    
    /* _M.certificateChain    = c_decode(func_get_share_dict_data("CertificateChain0")) */
    lc_getupvalue(L,lua_upvalueindex(1),14,3);
    const int lc170 = lua_gettop(L);
    lc_getupvalue(L,lua_upvalueindex(1),3,14);
    lua_pushliteral(L,"CertificateChain0");
    lua_call(L,1,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc170),1);
    lc_getupvalue(L,lua_upvalueindex(1),10,7);
    lua_insert(L,-2);
    lua_pushliteral(L,"certificateChain");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 0);
    
    /* _M.g_server_id		   = func_get_share_dict_data("GetKeyID0") */
    lc_getupvalue(L,lua_upvalueindex(1),3,14);
    lua_pushliteral(L,"GetKeyID0");
    lua_call(L,1,1);
    lc_getupvalue(L,lua_upvalueindex(1),10,7);
    lua_insert(L,-2);
    lua_pushliteral(L,"g_server_id");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 0);
    
    /* _M.g_selectedAlgorithm = func_get_share_dict_data("GetAlgorithm0") */
    lc_getupvalue(L,lua_upvalueindex(1),3,14);
    lua_pushliteral(L,"GetAlgorithm0");
    lua_call(L,1,1);
    lc_getupvalue(L,lua_upvalueindex(1),10,7);
    lua_insert(L,-2);
    lua_pushliteral(L,"g_selectedAlgorithm");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L,lc167);
  assert(lua_gettop(L) == 0);
  
  /* ---force request body 
   * ---this was harmful performance
   * bodyReader() */
  lc_getupvalue(L,lua_upvalueindex(1),0,17);
  lua_call(L,0,0);
  assert(lua_gettop(L) == 0);
  
  /* local body_str = ngx.req.get_body_data() */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc171 = 1 };
  assert((lua_gettop(L) == lc171));
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"req");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"get_body_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_rawseti(L,lc171,20);
  assert(lua_gettop(L) == 1);
  
  /* if body_str == nil then */
  enum { lc172 = 1 };
  lc_getupvalue(L,lc171,0,20);
  lua_pushnil(L);
  const int lc173 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc173);
  const int lc174 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc174) {
    
    /* local file_name = ngx.req.get_body_file() */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"req");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"get_body_file");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,1);
    assert(lua_gettop(L) == 2);
    
    /* if file_name then */
    enum { lc175 = 2 };
    if (lua_toboolean(L,2)) {
      
      /* body_str = get_file(file_name) */
      lua_getfield(L,LUA_ENVIRONINDEX,"get_file");
      lua_pushvalue(L,2);
      lua_call(L,1,1);
      lc_setupvalue(L,lc171,0,20);
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L,lc175);
    assert(lua_gettop(L) == 2);
    
    /* if nil == body_str then */
    enum { lc176 = 2 };
    lua_pushnil(L);
    lc_getupvalue(L,lc171,0,20);
    const int lc177 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc177);
    const int lc178 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc178) {
      
      /* ngx.exit(ngx.HTTP_BAD_REQUEST) */
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"exit");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"HTTP_BAD_REQUEST");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 2);
      
      /* return; */
      return 0;
      assert(lua_gettop(L) == 2);
    }
    lua_settop(L,lc176);
    assert(lua_gettop(L) == 2);
  }
  lua_settop(L,lc172);
  assert(lua_gettop(L) == 1);
  
  /* ngx.log(ngx.ERR, "request body" .. body_str) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"log");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ERR");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"request body");
  lc_getupvalue(L,lc171,0,20);
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 1);
  
  /* local node  = nil */
  lc_newclosuretable(L,lc171);
  enum { lc179 = 2 };
  assert((lua_gettop(L) == lc179));
  lua_pushnil(L);
  lua_rawseti(L,lc179,21);
  assert(lua_gettop(L) == 2);
  
  /* local invalidate =  pcall(function () 
   * 		node = c_decode(body_str);
   * 	end) */
  lua_getfield(L,LUA_ENVIRONINDEX,"pcall");
  lua_pushvalue(L,lc179);
  lua_pushcclosure(L,lcf180,1);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 3);
  
  /* if node == nil then */
  enum { lc181 = 3 };
  lc_getupvalue(L,lc179,0,21);
  lua_pushnil(L);
  const int lc182 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc182);
  const int lc183 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc183) {
    
    /* if ngx.ctx.status == "success" then */
    enum { lc184 = 3 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"status");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"success");
    const int lc185 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc185);
    const int lc186 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc186) {
      
      /* ngx.ctx.status = "malformedRequest" */
      lua_pushliteral(L,"malformedRequest");
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ctx");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"status");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc184);
    assert(lua_gettop(L) == 3);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 3);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc181);
  assert(lua_gettop(L) == 3);
  
  /* -- if not ngx.ctx.test then
   * ngx.ctx.deviceID = node.deviceID */
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"deviceID");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"deviceID");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  
  /* if not node.deviceID then */
  enum { lc187 = 3 };
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"deviceID");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc188 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc188) {
    
    /* ngx.ctx.status = "abort" */
    lua_pushliteral(L,"abort");
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"status");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 3);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc187);
  assert(lua_gettop(L) == 3);
  
  /* ngx.ctx.nonce    = node.nonce */
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"nonce");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"nonce");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) == 3);
  
  /* if (not node.nonce) or (node.nonce == "") then */
  enum { lc189 = 3 };
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"nonce");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lc_getupvalue(L,lc179,0,21);
    lua_pushliteral(L,"nonce");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"");
    const int lc190 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc190);
  }
  const int lc191 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc191) {
    
    /* ngx.ctx.status = "abort" */
    lua_pushliteral(L,"abort");
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"status");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 3);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc189);
  assert(lua_gettop(L) == 3);
  
  /* if (not node.version) or (node.version ~= "2.0") then */
  enum { lc192 = 3 };
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"version");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lc_getupvalue(L,lc179,0,21);
    lua_pushliteral(L,"version");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"2.0");
    const int lc193 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc193);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc194 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc194) {
    
    /* --TODO default 
     * if ngx.ctx.status == "success" then */
    enum { lc195 = 3 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"status");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"success");
    const int lc196 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc196);
    const int lc197 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc197) {
      
      /* ngx.ctx.status = "versionNotSupported" */
      lua_pushliteral(L,"versionNotSupported");
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ctx");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"status");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc195);
    assert(lua_gettop(L) == 3);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 3);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc192);
  assert(lua_gettop(L) == 3);
  
  /* if (not node.type) or (node.type ~= "licenseRequest") then */
  enum { lc198 = 3 };
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"type");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lc_getupvalue(L,lc179,0,21);
    lua_pushliteral(L,"type");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"licenseRequest");
    const int lc199 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc199);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc200 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc200) {
    
    /* --TODO default 
     * if ngx.ctx.status == "success" then */
    enum { lc201 = 3 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"status");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"success");
    const int lc202 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc202);
    const int lc203 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc203) {
      
      /* ngx.ctx.status = "typeNotSupported" */
      lua_pushliteral(L,"typeNotSupported");
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ctx");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"status");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 3);
    }
    lua_settop(L,lc201);
    assert(lua_gettop(L) == 3);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 3);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc198);
  assert(lua_gettop(L) == 3);
  
  /* if (not node.contentIDs) then */
  enum { lc204 = 3 };
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"contentIDs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc205 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc205) {
    
    /* ngx.ctx.status = "contentIDNotFound" */
    lua_pushliteral(L,"contentIDNotFound");
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"status");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 3);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc204);
  assert(lua_gettop(L) == 3);
  
  /* ----多个content ID是PSSHbox 的情况
   * ----需要多次处理替换原有的ContentID
   * -- node.contentIDs[1] = [[AAAAo3Bzc2gAAAAAPV5tNZuaQei4Q908bnLELAAAAIN7InZlcnNpb24iOiJWMS4wIiwiY29udGVudElEIjoiTVRBd01EQXhNREV5TXpRMU5qYzRPUT09Iiwia2lkcyI6WyJOelpsTnpSaU56YzBaREF4TkRSaU1XSXhPRE5tTlRnME1ERTRabVEzTVRrPSJdLCJlbnNjaGVtYSI6ImNlbmMifQ]]
   * -- node.contentIDs[2] = [[AAAAtXBzc2gAAAAAPV5tNZuaQei4Q908bnLELAAAAJV7InZlcnNpb24iOiJWMS4wIiwiY29udGVudElEIjoiY0c5cGRXNWlkbUZ6WkdabmFHdHgiLCJraWRzIjpbIk56WmxOelJpTnpjMFpEQXhORFJpTVdJeE9ETm1OVGcwTURFNFptUTNNVGs9Il0sImVuc2NoZW1hIjoic200YyIsImV4dGVuc2lvbnMiOiJzdHJpbmcifQ]]
   * for i=1,#node.contentIDs,1 do */
  lua_pushnumber(L,1);
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"contentIDs");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const double lc209 = lua_objlen(L,-1);
  lua_pop(L,1);
  lua_pushnumber(L,lc209);
  lua_pushnumber(L,1);
  if (!(((lua_isnumber(L,-3) && lua_isnumber(L,-2)) && lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc206_var = lua_tonumber(L,-3);
  const double lc207_limit = lua_tonumber(L,-2);
  const double lc208_step = lua_tonumber(L,-1);
  lua_pop(L,3);
  enum { lc210 = 3 };
  while ((((lc208_step > 0) && (lc206_var <= lc207_limit)) || ((lc208_step <= 0) && (lc206_var >= lc207_limit)))) {
    
    /* internal: local i at index 4 */
    lua_pushnumber(L,lc206_var);
    
    /* _M.pssh_check(node.contentIDs[i]) */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"pssh_check");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc179,0,21);
    lua_pushliteral(L,"contentIDs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,4);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 4);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc206_var += lc208_step;
  }
  lua_settop(L,lc210);
  assert(lua_gettop(L) == 3);
  
  /* if (not node.supportedAlgorithms)  or (node.supportedAlgorithms[1] ~= "KMSProfile1") then */
  enum { lc211 = 3 };
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"supportedAlgorithms");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lc_getupvalue(L,lc179,0,21);
    lua_pushliteral(L,"supportedAlgorithms");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"KMSProfile1");
    const int lc212 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc212);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
  }
  const int lc213 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc213) {
    
    /* ngx.ctx.status = "abort" */
    lua_pushliteral(L,"abort");
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"status");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 3);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc211);
  assert(lua_gettop(L) == 3);
  
  /* if (not node.certificateChain ) or (#node.certificateChain < 2) then */
  enum { lc214 = 3 };
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"certificateChain");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lc_getupvalue(L,lc179,0,21);
    lua_pushliteral(L,"certificateChain");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    const double lc215 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc215);
    lua_pushnumber(L,2);
    const int lc216 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc216);
  }
  const int lc217 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc217) {
    
    /* ngx.ctx.status = "invalidCertificateChain" */
    lua_pushliteral(L,"invalidCertificateChain");
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"status");
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) == 3);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 3);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc214);
  assert(lua_gettop(L) == 3);
  
  /* local  verify_result = nil */
  lua_pushnil(L);
  assert(lua_gettop(L) == 4);
  
  /* if func_get_share_dict_data(ngx.ctx.deviceID .. ".chain") == nil then */
  enum { lc218 = 4 };
  lc_getupvalue(L,lc179,5,14);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"deviceID");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,".chain");
  lua_concat(L,2);
  lua_call(L,1,1);
  lua_pushnil(L);
  const int lc219 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc219);
  const int lc220 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc220) {
    
    /* ----校验客户端的证书链
     * verify_result = _M.verify_chain(body_str) */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"verify_chain");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_getupvalue(L,lc179,1,20);
    lua_call(L,1,1);
    lua_replace(L,4);
    assert(lua_gettop(L) == 4);
    
    /* if string.find(verify_result , "000") ~= nil then */
    enum { lc221 = 4 };
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,4);
    lua_pushliteral(L,"000");
    lua_call(L,2,1);
    lua_pushnil(L);
    const int lc222 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc222);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc223 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc223) {
      
      /* local cache_ngx = ngx.shared.ngx_share_dict */
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"shared");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,"ngx_share_dict");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) == 5);
      
      /* cache_ngx:set(node.deviceID .. ".chain" , 1) */
      lua_pushvalue(L,5);
      lua_pushliteral(L,"set");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lc_getupvalue(L,lc179,0,21);
      lua_pushliteral(L,"deviceID");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L,".chain");
      lua_concat(L,2);
      lua_pushnumber(L,1);
      lua_call(L,3,0);
      assert(lua_gettop(L) == 5);
    }
    lua_settop(L,lc221);
    assert(lua_gettop(L) == 4);
  }
  else {
    
    /* else
     * verify_result = mverify (body_str) */
    lc_getupvalue(L,lc179,3,16);
    lc_getupvalue(L,lc179,1,20);
    lua_call(L,1,1);
    lua_replace(L,4);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc218);
  assert(lua_gettop(L) == 4);
  
  /* if (not verify_result) then */
  enum { lc224 = 4 };
  lua_pushboolean(L,!(lua_toboolean(L,4)));
  const int lc225 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc225) {
    
    /* -- ngx.log(ngx.ERR, "error::failed..")
     * if ngx.ctx.status == "success" then */
    enum { lc226 = 4 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"status");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"success");
    const int lc227 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc227);
    const int lc228 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc228) {
      
      /* ngx.ctx.status = "abort" */
      lua_pushliteral(L,"abort");
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ctx");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"status");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc226);
    assert(lua_gettop(L) == 4);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 4);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc224);
  assert(lua_gettop(L) == 4);
  
  /* verify_result = cjson.decode(verify_result) */
  lc_getupvalue(L,lc179,18,1);
  lua_pushliteral(L,"decode");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,4);
  lua_call(L,1,1);
  lua_replace(L,4);
  assert(lua_gettop(L) == 4);
  
  /* if verify_result.code ~= "000" then */
  enum { lc229 = 4 };
  lua_pushliteral(L,"code");
  lua_gettable(L,4);
  lua_pushliteral(L,"000");
  const int lc230 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc230);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc231 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc231) {
    
    /* --ngx.log(ngx.ERR, "verify is block");
     * if ngx.ctx.status == "success" then */
    enum { lc232 = 4 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"status");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"success");
    const int lc233 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc233);
    const int lc234 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc234) {
      
      /* ngx.ctx.status = verify_result.details */
      lua_pushliteral(L,"details");
      lua_gettable(L,4);
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ctx");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"status");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc232);
    assert(lua_gettop(L) == 4);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 4);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc229);
  assert(lua_gettop(L) == 4);
  
  /* ------------------------------------------------------------
   * -- local OLD1 = node.deviceID;
   * -- local OLD2 = node.nonce;
   * -- -- node.deviceID = "RND_" .. math.random(10000);
   * -- node.nonce    = node.deviceID;
   * ------------------------------------------------------------
   * ----- crl 
   * -- if node.certificateChain then
   * -- 	ngx.ctx.cert = node.certificateChain[1];
   * -- 	_M.crl_check(node.deviceID)
   * -- end
   * -- suma_crl_deviceID
   * -- if not black_list_m.forbid(node.deviceID) then
   * -- 	if ngx.ctx.status == "success" then
   * -- 		ngx.ctx.status = "accessDenied";
   * -- 	end
   * -- 	ngx.log(ngx.ERR, "black_list block");
   * -- 	_M.default_response_print();
   * -- 	ngx.exit(200);
   * -- end
   * -- if (_M.check_time_correct(tonumber(node.requestTime)) == false) then
   * -- 	ngx.log(ngx.ERR, "request time is not invalidate");
   * -- 	if ngx.ctx.status == "success" then
   * -- 		ngx.ctx.status = "deviceTimeError";
   * -- 	end
   * -- end
   * -- if  ngx.ctx.test then
   * -- 	local cache_ngx = ngx.shared.ngx_share_dict;
   * -- 	local cache     = cache_ngx:get(node.nonce);
   * -- 	if cache ~= nil then
   * -- 		ngx.ctx.status = "abort";
   * -- 		_M.default_response_print();
   * -- 		ngx.exit(200);
   * -- 		ngx.log(ngx.ERR, "this is nonce id block.");
   * -- 		return cache;
   * -- 	end
   * -- 	cache_ngx:set(node.nonce, 1);
   * -- end
   * --local template  = require "resty.template"
   * --local render_ri = template.suma_ri_response;
   * local contentIds = _M.get_content_id_from_req(node) */
  lc_getupvalue(L,lc179,12,7);
  lua_pushliteral(L,"get_content_id_from_req");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lc179,0,21);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 5);
  
  /* local ecek       = _M.get_ecek_from_key_gate (node, contentIds) */
  lc_getupvalue(L,lc179,12,7);
  lua_pushliteral(L,"get_ecek_from_key_gate");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lc179,0,21);
  lua_pushvalue(L,5);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 6);
  
  /* --ngx.log(ngx.ERR, "ecek=" .. ecek);
   * if ecek == nil then */
  enum { lc235 = 6 };
  lua_pushnil(L);
  const int lc236 = lua_equal(L,6,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc236);
  const int lc237 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc237) {
    
    /* ngx.log(ngx.ERR, "key gate way is block") */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"log");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ERR");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"key gate way is block");
    lua_call(L,2,0);
    assert(lua_gettop(L) == 6);
    
    /* if ngx.ctx.status == "success" then */
    enum { lc238 = 6 };
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"ctx");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"status");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"success");
    const int lc239 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc239);
    const int lc240 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc240) {
      
      /* ngx.ctx.status = "contentIDNotFound" */
      lua_pushliteral(L,"contentIDNotFound");
      lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
      lua_pushliteral(L,"ctx");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"status");
      lua_insert(L,-2);
      lua_settable(L,-3);
      lua_pop(L,1);
      assert(lua_gettop(L) == 6);
    }
    lua_settop(L,lc238);
    assert(lua_gettop(L) == 6);
    
    /* _M.default_response_print() */
    lc_getupvalue(L,lc179,12,7);
    lua_pushliteral(L,"default_response_print");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_call(L,0,0);
    assert(lua_gettop(L) == 6);
    
    /* ngx.exit(200) */
    lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,200);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 6);
    
    /* return; */
    return 0;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc235);
  assert(lua_gettop(L) == 6);
  
  /* -- local aaa = _M.get_acc_from_aaa_gate(node, contentIds);
   * -- if not aaa then
   * -- 	ngx.log(ngx.ERR, "aaa connect failed");
   * -- 	ngx.exit(500);
   * -- 	return;
   * -- end
   * -- local aaa_result = cjson.decode(ecek);
   * -- if aaa_result.status ~= "success" then
   * -- 	ngx.ctx.status = "abort";
   * -- 	_M.default_response_print();
   * -- 	ngx.exit(200);
   * -- 	ngx.log(ngx.ERR, "aaa failed");
   * -- 	return;
   * -- end
   * --[[
   * 	if eax(ecek) ~= '0' then
   * 		ngx.log(ngx.ERR, "key gate way is block");
   * 		ngx.exit(500);
   * 	end
   * 	--]]
   * --[[if node.deviceID == nil then
   * 		ngx.log(ngx.ERR, "key gate way is block");
   * 		ngx.exit(500);
   * 		return;
   * 	end
   * 	--]]
   * --if  not license then
   * --ngx.log(ngx.ERR, "ecek" .. ecek);
   * --ngx.log(ngx.ERR, "deviceId" ..  node.deviceID);
   * --end
   * ---------------------------------------------------
   * ---relloc 
   * local packer = {
   * 		["drmClientCertificate"] = "",
   * 		["keyResponse"] = "",
   * 		["deviceID"] = ""
   * 	} */
  lua_createtable(L,0,3);
  lua_pushliteral(L,"drmClientCertificate");
  lua_pushliteral(L,"");
  lua_rawset(L,-3);
  lua_pushliteral(L,"keyResponse");
  lua_pushliteral(L,"");
  lua_rawset(L,-3);
  lua_pushliteral(L,"deviceID");
  lua_pushliteral(L,"");
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 7);
  
  /* ---test
   * --local  test = [[{"type":"keyResponse","version":"1.0","keyGateWayID":"K5gvdvIqkO15/VyiWA9D1laOmZrLj21YhV+x6iCMw24=","nonce":"kuYqz45291w7hpRnRBONJJOW2UY=","status":"success","selectedAlgorithm":"KMSProfile1","certificateChain":["MIIBujCCAWGgAwIBAgIEIHwhZzAKBggqgRzPVQGDdTA0MQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTEWMBQGA1UEAwwNRFJNIFNlcnZlciBDQTAeFw0xOTA1MDUwNzAwMDBaFw0yNDA1MDYwNjU5NTlaMD8xCzAJBgNVBAYMAkNOMRQwEgYDVQQKDAtTdW1hIFZpc2lvbjEaMBgGA1UEAwwRQ0RSTS1QT0MtS0dXLVNVTUEwWTATBgcqhkjOPQIBBggqgRzPVQGCLQNCAAS+JIbKf7puoYnvCqzmpbV3gax9AdVaLPAMBEWunR7SbfIQO9+yy5t7FKxdgsnAg76OdDTbt3X+TDDeysqmjWc7o1YwVDAOBgNVHQ8BAf8EBAMCB4AwFQYDVR0lAQH/BAswCQYHKoEchu8wGDArBgNVHSMEJDAigCCoXjDqV093IYgV+10OcAxe/hMvkFAT2JbGzeCG1j8ONzAKBggqgRzPVQGDdQNHADBEAiA22S6prBdSVjhg31fFrACZ/wyftPg1YL9f240DEOPrSQIgQ9HXrmK1weF+heckOHdVEP+2TFmJHMvrcVAKzdRMw4g=","MIIB1TCCAXqgAwIBAgIEPpdMHjAKBggqgRzPVQGDdTAuMQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTEQMA4GA1UEAwwHUm9vdCBDQTAgFw0xOTA1MDUwNzAwMDBaGA8yMDY5MDUwNjA2NTk1OVowNDELMAkGA1UEBgwCQ04xDTALBgNVBAoMBENEVEExFjAUBgNVBAMMDURSTSBTZXJ2ZXIgQ0EwWTATBgcqhkjOPQIBBggqgRzPVQGCLQNCAATBrbIBDT0ZVzSujLTaN+M/6kNFJnBHf+ON4h4Td3ecuqDs3OsX8lzCe2ps3Q9GgkOlTdQvDn0EDc05/Nr93X9Io34wfDApBgNVHQ4EIgQgqF4w6ldPdyGIFftdDnAMXv4TL5BQE9iWxs3ghtY/DjcwDgYDVR0PAQH/BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwKwYDVR0jBCQwIoAg/gShDd110f1FY3fkB+CnCG3gVNkdP8YZv8jbk5SCNNEwCgYIKoEcz1UBg3UDSQAwRgIhAMryOGAga/re2g90+UM9y/tyP4u/TmjP2i1M0BW5vrxiAiEAo/3pXEtWM1z1VbdeV39uGZDmdNSSmLiKhLvz1MvS0hE="],"signature":"BbXYFe1s572L6dndaE+zyXDtUhrZTNGX64sIOSAJc7MghPTvRC71DqbEpohUjtcBELKBTMqQoeXNaPxvIdEJhw==","cekInfos":[{"contentID":"Um90YUtleUxpdmVTbm0=","sessionKeyID":"uAXDMxEgi77XiyHDJ8QFrA==","encSessionKey":"BJgd3JdXsSooY7T/5GIZitBLM7i+FLf00U6ItsJkDcRNlYgiZUSghWqBNMmrCEBGr9bOUwdQ6Qjz/GDT3iItlINba4DWjRWRWG3CHykBqQw8gl8AbKO9zcyQyxSfs18OyZtnH/SzKIKx6zYdHlXR+p4=","encCEKs":[{"cekID":"YExCgSKD3uniX9sNlLWiRw==","encCEK":"9i2vJxTxzM9USBhVDVwJCA=="},{"cekID":"EGCw+DFXrkfLhPmpqIfhYw==","encCEK":"RAMVDiNVhswF1KUz+8LcDA=="},{"cekID":"RtbY6XyzOh32BdUMLU4Ipw==","encCEK":"5QKH38bOcEGq9bnmcBb2OQ=="}],"contentRules":"BQEEXxekxAIEce+FRAQEAAAAluAEX1X1YOEEX1X3Ig=="}]}]]
   * packer.drmClientCertificate = node.certificateChain[1] */
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"certificateChain");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"drmClientCertificate");
  lua_insert(L,-2);
  lua_settable(L,7);
  assert(lua_gettop(L) == 7);
  
  /* packer.keyResponse          = ecek */
  lua_pushvalue(L,6);
  lua_pushliteral(L,"keyResponse");
  lua_insert(L,-2);
  lua_settable(L,7);
  assert(lua_gettop(L) == 7);
  
  /* packer.deviceID             = node.deviceID */
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"deviceID");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"deviceID");
  lua_insert(L,-2);
  lua_settable(L,7);
  assert(lua_gettop(L) == 7);
  
  /* if aaa ~= nil then */
  enum { lc241 = 7 };
  lua_getfield(L,LUA_ENVIRONINDEX,"aaa");
  lua_pushnil(L);
  const int lc242 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc242);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc243 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc243) {
    
    /* packer.aaaResponse          = aaa */
    lua_getfield(L,LUA_ENVIRONINDEX,"aaa");
    lua_pushliteral(L,"aaaResponse");
    lua_insert(L,-2);
    lua_settable(L,7);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc241);
  assert(lua_gettop(L) == 7);
  
  /* local license = _M.pack_license(node, packer) */
  lc_getupvalue(L,lc179,12,7);
  lua_pushliteral(L,"pack_license");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lc179,0,21);
  lua_pushvalue(L,7);
  lua_call(L,2,1);
  assert(lua_gettop(L) == 8);
  
  /* --[[
   * 	local license    = suma_c_api.ngx_suma_pack_license(
   * 		node.deviceID,
   * 		ecek
   * 	);
   * 
   * 	if  not license then
   * 		ngx.log(ngx.ERR, "ecek" .. ecek);
   * 		ngx.log(ngx.ERR, "deviceId" ..  node.deviceID);
   * 		ngx.exit(500);
   * 		return;
   * 	end
   * 	--]]
   * ---relloc 
   * local res  = {
   * 		["version"] = 1,
   * 		["type"]    = 1,
   * 		["status"]  = 1,
   * 		["protectedLicenses"] = 1,
   * 		["responseTime"] = 1,
   * 		["certificateChain"] = 1,
   * 		["drmServerID"] = 1,
   * 		["selectedAlgorithm"] = 1,
   * 		["deviceID"] = 1,
   * 		["nonce"] = 1
   *  	} */
  lua_createtable(L,0,10);
  lua_pushliteral(L,"version");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"type");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"status");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"protectedLicenses");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"responseTime");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"certificateChain");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"drmServerID");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"selectedAlgorithm");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"deviceID");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"nonce");
  lua_pushnumber(L,1);
  lua_rawset(L,-3);
  assert(lua_gettop(L) == 9);
  
  /* res.version = node.version */
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"version");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"version");
  lua_insert(L,-2);
  lua_settable(L,9);
  assert(lua_gettop(L) == 9);
  
  /* res.type    = "licenseResponse" */
  lua_pushliteral(L,"licenseResponse");
  lua_pushliteral(L,"type");
  lua_insert(L,-2);
  lua_settable(L,9);
  assert(lua_gettop(L) == 9);
  
  /* res.status  = ngx.ctx.status */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ctx");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"status");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"status");
  lua_insert(L,-2);
  lua_settable(L,9);
  assert(lua_gettop(L) == 9);
  
  /* res.protectedLicenses = license */
  lua_pushvalue(L,8);
  lua_pushliteral(L,"protectedLicenses");
  lua_insert(L,-2);
  lua_settable(L,9);
  assert(lua_gettop(L) == 9);
  
  /* res.responseTime      = ngx.time().. "" */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"time");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_call(L,0,1);
  lua_pushliteral(L,"");
  lua_concat(L,2);
  lua_pushliteral(L,"responseTime");
  lua_insert(L,-2);
  lua_settable(L,9);
  assert(lua_gettop(L) == 9);
  
  /* res.certificateChain  = _M.certificateChain */
  lc_getupvalue(L,lc179,12,7);
  lua_pushliteral(L,"certificateChain");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"certificateChain");
  lua_insert(L,-2);
  lua_settable(L,9);
  assert(lua_gettop(L) == 9);
  
  /* res.drmServerID		  = _M.g_server_id */
  lc_getupvalue(L,lc179,12,7);
  lua_pushliteral(L,"g_server_id");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"drmServerID");
  lua_insert(L,-2);
  lua_settable(L,9);
  assert(lua_gettop(L) == 9);
  
  /* res.selectedAlgorithm = _M.g_selectedAlgorithm */
  lc_getupvalue(L,lc179,12,7);
  lua_pushliteral(L,"g_selectedAlgorithm");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"selectedAlgorithm");
  lua_insert(L,-2);
  lua_settable(L,9);
  assert(lua_gettop(L) == 9);
  
  /* res.deviceID          = node.deviceID */
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"deviceID");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"deviceID");
  lua_insert(L,-2);
  lua_settable(L,9);
  assert(lua_gettop(L) == 9);
  
  /* res.nonce             = node.nonce */
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"nonce");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"nonce");
  lua_insert(L,-2);
  lua_settable(L,9);
  assert(lua_gettop(L) == 9);
  
  /* --local test = '{"type":"licenseResponse","version":"2.0","status":"success","selectedAlgorithm":"KMSProfile1","responseTime":"1599188389","deviceID":"zdx/5YDHb5pIzqbNzxA1b1CmUbigqNoeaGl4yz8IN8g=","drmServerID":"/XHjg6n6nbVknQCOiQp4DbDDFCIAt1ZaTMPi59OQlvc=","nonce":"AAECAwQFBgcICQoLDA0ODxAR","protectedLicenses":[{"licenseID":"X1Gtpex1fm8=","license":"AAAADgJfUa2l7HV+bwtfUa2lAQEAQw5Sb3RhS2V5TGl2ZVNubQMQBPYUg58owlPhz/xhS2qQhBDgdKOLZVj4HpgM09AKTIgmECSqk6h4x7NbBEvnPhKEae8CAgAhAM3cf+WAx2+aSM6mzc8QNW9QplG4oKjaHmhpeMs/CDfIAwMAqBIAcQQazDChM1ioCBeMOL/fZXiI2KKpDlIArnvxRRh4RyrHYoI/d2nEZlDdP8zU9GtT5nFxrA/8DETy2n4mpYD20WEHZwYGNYabFiM4FM0ci7Yv/jX2JfupbZCF3YuqbvG4t0W8jIy0R8NyO1k+H2iXvMraIBCUUu4/DlPCeE7K1kIiDBHpAyDN3H/lgMdvmkjOps3PEDVvUKZRuKCo2h5oaXjLPwg3yAMEADciABA01cGjqwA4NozCTdb8De+aARAE9hSDnyjCU+HP/GFLapCEIBCUUu4/DlPCeE7K1kIiDBHpAwUANyIAEJlqzUJDe8rx/dBpq+XLIi0BEOB0o4tlWPgemAzT0ApMiCYgEJRS7j8OU8J4TsrWQiIMEekDBgA3IgAQnY/QLEH1uG8P42y/pOZD2AEQJKqTqHjHs1sES+c+EoRp7yAQlFLuPw5TwnhOytZCIgwR6QMHALgSAIEE7l0SeQqBM1nfFQqMbwJO2hoT/G7j+DNIGzONICBg+8Q173y6y+oHAptMxUz0Tl+ODWncrDUrTnaa0gcCn9WFhwBDTwvfbTXdO0aMVSLgxpu5UDN7LissKk9Jyg6eNHBIrw+o95rqkkKXYjlQZOfWaCgswwpoYhh5O3AnmZsebbQhEOx1fm6+0BQlSijmWhAHlJ4DIM3cf+WAx2+aSM6mzc8QNW9QplG4oKjaHmhpeMs/CDfIBAgAMQEQBPYUg58owlPhz/xhS2qQhAUBBF8XpMQCBHHvhUQEBAAAAJbgBF9RrIDhBF9RrkIECQAxARDgdKOLZVj4HpgM09AKTIgmBQEEXxekxAIEce+FRAQEAAAAluAEX1GsgOEEX1GuQgQKADEBECSqk6h4x7NbBEvnPhKEae8FAQRfF6TEAgRx74VEBAQAAACW4ARfUayA4QRfUa5C/wsANEMQ7HV+br7QFCVKKOZaEAeUngAgSHd90WGXWux6C03GrdIBdqSwlD/U034eEO9hwMNaOgo="}],"certificateChain":["MIIBwTCCAWegAwIBAgIEEciBXDAKBggqgRzPVQGDdTA0MQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTEWMBQGA1UEAwwNRFJNIFNlcnZlciBDQTAeFw0xOTA1MDUwNzAwMDBaFw0yNDA1MDYwNjU5NTlaMEUxCzAJBgNVBAYMAkNOMRQwEgYDVQQKDAtTdW1hIFZpc2lvbjEgMB4GA1UEAwwXQ0RSTS1QT0MtRFJNU0VSVkVSLVNVTUEwWTATBgcqhkjOPQIBBggqgRzPVQGCLQNCAARazBO7QgpeM81WW2smbaAPiM0Ag6UhpL41IMaHgkMyH/L4spTaJtuCC7U9wIbcztH0ABCd4iPgXAXepW/cuVDTo1YwVDAOBgNVHQ8BAf8EBAMCB4AwFQYDVR0lAQH/BAswCQYHKoEchu8wBzArBgNVHSMEJDAigCCoXjDqV093IYgV+10OcAxe/hMvkFAT2JbGzeCG1j8ONzAKBggqgRzPVQGDdQNIADBFAiEAkuZ0QIgSY5vpuUVNB4ivlXQOnbTv+FmrBnbunhq/8awCIDSSetEBslOtsqXEsWzCr89+GI8Q1KsgH7vShrQ83GeK","MIIB1TCCAXqgAwIBAgIEPpdMHjAKBggqgRzPVQGDdTAuMQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTEQMA4GA1UEAwwHUm9vdCBDQTAgFw0xOTA1MDUwNzAwMDBaGA8yMDY5MDUwNjA2NTk1OVowNDELMAkGA1UEBgwCQ04xDTALBgNVBAoMBENEVEExFjAUBgNVBAMMDURSTSBTZXJ2ZXIgQ0EwWTATBgcqhkjOPQIBBggqgRzPVQGCLQNCAATBrbIBDT0ZVzSujLTaN+M/6kNFJnBHf+ON4h4Td3ecuqDs3OsX8lzCe2ps3Q9GgkOlTdQvDn0EDc05/Nr93X9Io34wfDApBgNVHQ4EIgQgqF4w6ldPdyGIFftdDnAMXv4TL5BQE9iWxs3ghtY/DjcwDgYDVR0PAQH/BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwKwYDVR0jBCQwIoAg/gShDd110f1FY3fkB+CnCG3gVNkdP8YZv8jbk5SCNNEwCgYIKoEcz1UBg3UDSQAwRgIhAMryOGAga/re2g90+UM9y/tyP4u/TmjP2i1M0BW5vrxiAiEAo/3pXEtWM1z1VbdeV39uGZDmdNSSmLiKhLvz1MvS0hE="]}'
   * --local str_req = test ;-- cjson.encode(res) ;
   * local str_req = cjson.encode(res) */
  lc_getupvalue(L,lc179,18,1);
  lua_pushliteral(L,"encode");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,9);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 10);
  
  /* str_req = igsub(str_req, "%\\%/", "%/") */
  lc_getupvalue(L,lc179,4,15);
  lua_pushvalue(L,10);
  lua_pushliteral(L,"%\\%/");
  lua_pushliteral(L,"%/");
  lua_call(L,3,1);
  lua_replace(L,10);
  assert(lua_gettop(L) == 10);
  
  /* local n_str = isub(str_req,1,ilen(str_req)-1) */
  lc_getupvalue(L,lc179,15,4);
  lua_pushvalue(L,10);
  lua_pushnumber(L,1);
  lc_getupvalue(L,lc179,14,5);
  lua_pushvalue(L,10);
  lua_call(L,1,1);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_call(L,3,1);
  assert(lua_gettop(L) == 11);
  
  /* local ocsp_res   = "" */
  lua_pushliteral(L,"");
  assert(lua_gettop(L) == 12);
  
  /* --_M.ocsp_get();
   * local ocsp_state = false */
  lua_pushboolean(L,0);
  assert(lua_gettop(L) == 13);
  
  /* if node.extensions ~= nil then */
  enum { lc244 = 13 };
  lc_getupvalue(L,lc179,0,21);
  lua_pushliteral(L,"extensions");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnil(L);
  const int lc245 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc245);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc246 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc246) {
    
    /* local infos = node.extensions.drmServerInfos */
    lc_getupvalue(L,lc179,0,21);
    lua_pushliteral(L,"extensions");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"drmServerInfos");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    assert(lua_gettop(L) == 14);
    
    /* if infos ~= nil then */
    enum { lc247 = 14 };
    lua_pushnil(L);
    const int lc248 = lua_equal(L,14,-1);
    lua_pop(L,1);
    lua_pushboolean(L,lc248);
    lua_pushboolean(L,!(lua_toboolean(L,-1)));
    lua_remove(L,-2);
    const int lc249 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc249) {
      
      /* for i, v in ipairs (infos) do
       * internal: local f, s, var = explist */
      enum { lc250 = 14 };
      lua_getfield(L,LUA_ENVIRONINDEX,"ipairs");
      lua_pushvalue(L,14);
      lua_call(L,1,3);
      while (1) {
        
        /* internal: local var_1, ..., var_n = f(s, var)
         *           if var_1 == nil then break end
         *           var = var_1 */
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_pushvalue(L,-3);
        lua_call(L,2,2);
        if (lua_isnil(L,-2)) {
          break;
        }
        lua_pushvalue(L,-2);
        lua_replace(L,-4);
        
        /* internal: local i with idx 18
         * internal: local v with idx 19 */
        
        
        /* if v.drmServerID == _M.g_server_id then */
        enum { lc251 = 19 };
        lua_pushliteral(L,"drmServerID");
        lua_gettable(L,19);
        lc_getupvalue(L,lc179,12,7);
        lua_pushliteral(L,"g_server_id");
        lua_gettable(L,-2);
        lua_remove(L,-2);
        const int lc252 = lua_equal(L,-2,-1);
        lua_pop(L,2);
        lua_pushboolean(L,lc252);
        const int lc253 = lua_toboolean(L,-1);
        lua_pop(L,1);
        if (lc253) {
          
          /* ocsp_state = v.ocspState */
          lua_pushliteral(L,"ocspState");
          lua_gettable(L,19);
          lua_replace(L,13);
          assert(lua_gettop(L) == 19);
        }
        lua_settop(L,lc251);
        assert(lua_gettop(L) == 19);
        
        /* internal: stack cleanup on scope exit */
        lua_pop(L,2);
      }
      lua_settop(L,lc250);
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc247);
    assert(lua_gettop(L) == 14);
  }
  lua_settop(L,lc244);
  assert(lua_gettop(L) == 13);
  
  /* if ocsp_state ~= true then */
  enum { lc254 = 13 };
  lua_pushboolean(L,1);
  const int lc255 = lua_equal(L,13,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc255);
  lua_pushboolean(L,!(lua_toboolean(L,-1)));
  lua_remove(L,-2);
  const int lc256 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc256) {
    
    /* ---从模块获取
     * -- ocsp_res = [[MIIDFgoBAKCCAw8wggMLBgkrBgEFBQcwAQEEggL8MIIC+DCBq6ADAgEBoiIEIPOW4/jInQt4Q+2u65kHUaSYV4L6SKPxINc9L32dZ2reGA8yMDIwMTAyNzA0MDcwOVowbzBtMFgwDAYIKoEcgUUBgxEFAAQgUqzdC4slHDMq8HdGMx15TlACo9AfDBI9RPUoLj4J0LoEIJMCaI45TBaMbNJbr6/w3oSt++P8z4zPavaWacoyHPr2AgQRyIFcggAYDzIwMjAxMDI3MDQwNzA5WjAMBggqgRzPVQGDdQUAA0gAMEUCIQCHxZr7dy1bTtidpMMnFmpxEFUzhCqnzN2RvY1pHiWlvAIgA63JB+/9c2VQqL3ouARvfhIsCmwmJsCz8e6Qb7130LagggHuMIIB6jCCAeYwggGMoAMCAQICBGmnNx0wCgYIKoEcz1UBg3UwNDELMAkGA1UEBgwCQ04xDTALBgNVBAoMBENEVEExFjAUBgNVBAMMDURSTSBTZXJ2ZXIgQ0EwHhcNMjAwNzMwMTYwMDAwWhcNMjAxMDMxMTU1OTU5WjArMQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTENMAsGA1UEAwwET0NTUDBZMBMGByqGSM49AgEGCCqBHM9VAYItA0IABAT+e7tx1LOAgazwZQM/QFBGYaZszs9SptwKIzNSWAz2kP/jQSU1Lmtk1B127OZjjLLYtlQuwe7vFpGT4l2FstijgZQwgZEwKQYDVR0OBCIEIPOW4/jInQt4Q+2u65kHUaSYV4L6SKPxINc9L32dZ2reMA4GA1UdDwEB/wQEAwIHgDAWBgNVHSUBAf8EDDAKBggrBgEFBQcDCTAPBgkrBgEFBQcwAQUEAgUAMCsGA1UdIwQkMCKAIHCVPRGoDbM8NYQPuriI/jMfnNhPxuXq3m4KYkynOwZYMAoGCCqBHM9VAYN1A0gAMEUCIQDXMsPzOlFUnxFrfwVgU23RcG9vx7Xge8zW2fZ00nEBlQIgXVs8pSr6vRUf2GhOG2dai58qAHXRaFJnYpdUUPXzcHE=]];
     * -- sign     = gconcat ({n_str , ",\"ocspResponse\":\"" , ocsp_res , "\",\"signature\":\"\"}"});
     * --resp_str = gconcat ({n_str , ",\"ocspResponse\":\"" , ocsp_res , "\",\"signature\":\"" , csignature (sign) , "\"}"});
     * sign     = gconcat ({n_str , ",\"signature\":\"\"}"}) */
    lc_getupvalue(L,lc179,13,6);
    lua_createtable(L,2,0);
    lua_pushvalue(L,11);
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,",\"signature\":\"\"}");
    lua_rawseti(L,-2,2);
    lua_call(L,1,1);
    lua_setfield(L,LUA_ENVIRONINDEX,"sign");
    assert(lua_gettop(L) == 13);
    
    /* resp_str = gconcat ({n_str , ",\"signature\":\"" , csignature (sign) , "\"}"}) */
    lc_getupvalue(L,lc179,13,6);
    lua_createtable(L,4,0);
    lua_pushvalue(L,11);
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,",\"signature\":\"");
    lua_rawseti(L,-2,2);
    lc_getupvalue(L,lc179,8,11);
    lua_getfield(L,LUA_ENVIRONINDEX,"sign");
    lua_call(L,1,1);
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"\"}");
    lua_rawseti(L,-2,4);
    lua_call(L,1,1);
    lua_setfield(L,LUA_ENVIRONINDEX,"resp_str");
    assert(lua_gettop(L) == 13);
  }
  else {
    
    /* else
     * sign     = gconcat ({n_str , ",\"signature\":\"\"}"}) */
    lc_getupvalue(L,lc179,13,6);
    lua_createtable(L,2,0);
    lua_pushvalue(L,11);
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,",\"signature\":\"\"}");
    lua_rawseti(L,-2,2);
    lua_call(L,1,1);
    lua_setfield(L,LUA_ENVIRONINDEX,"sign");
    assert(lua_gettop(L) == 13);
    
    /* resp_str = gconcat ({n_str , ",\"signature\":\"" , csignature (sign) , "\"}"}) */
    lc_getupvalue(L,lc179,13,6);
    lua_createtable(L,4,0);
    lua_pushvalue(L,11);
    lua_rawseti(L,-2,1);
    lua_pushliteral(L,",\"signature\":\"");
    lua_rawseti(L,-2,2);
    lc_getupvalue(L,lc179,8,11);
    lua_getfield(L,LUA_ENVIRONINDEX,"sign");
    lua_call(L,1,1);
    lua_rawseti(L,-2,3);
    lua_pushliteral(L,"\"}");
    lua_rawseti(L,-2,4);
    lua_call(L,1,1);
    lua_setfield(L,LUA_ENVIRONINDEX,"resp_str");
    assert(lua_gettop(L) == 13);
  }
  lua_settop(L,lc254);
  assert(lua_gettop(L) == 13);
  
  /* ngx.log(ngx.ERR, "resp3=" .. resp_str) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"log");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"ERR");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"resp3=");
  lua_getfield(L,LUA_ENVIRONINDEX,"resp_str");
  lua_concat(L,2);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 13);
  
  /* ngx.print(resp_str) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"print");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"resp_str");
  lua_call(L,1,0);
  assert(lua_gettop(L) == 13);
  
  /* ngx.exit(200) */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"exit");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushnumber(L,200);
  lua_call(L,1,0);
  assert(lua_gettop(L) == 13);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  lua_checkstack(L,34);
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* -----
   * ---  New RI Service 
   * ---  agent.zy
   * --   1202 增加extkey m3u8 -> pssh 获取授权和秘钥
   * -----
   * local cjson = require("cjson") */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"require");
  lua_pushliteral(L,"cjson");
  lua_call(L,1,1);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* local http  = require("resty.http") */
  lc_newclosuretable(L,(lc1 + lc_nextra));
  enum { lc2 = 2 };
  assert((lua_gettop(L) == (lc2 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"require");
  lua_pushliteral(L,"resty.http");
  lua_call(L,1,1);
  lua_rawseti(L,(lc2 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* local c_decode = cjson.decode */
  lc_newclosuretable(L,(lc2 + lc_nextra));
  enum { lc3 = 3 };
  assert((lua_gettop(L) == (lc3 + lc_nextra)));
  lc_getupvalue(L,(lc2 + lc_nextra),1,1);
  lua_pushliteral(L,"decode");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc3 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* local isub = string.sub */
  lc_newclosuretable(L,(lc3 + lc_nextra));
  enum { lc4 = 4 };
  assert((lua_gettop(L) == (lc4 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"string");
  lua_pushliteral(L,"sub");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc4 + lc_nextra),4);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* local ilen = string.len */
  lc_newclosuretable(L,(lc4 + lc_nextra));
  enum { lc5 = 5 };
  assert((lua_gettop(L) == (lc5 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"string");
  lua_pushliteral(L,"len");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc5 + lc_nextra),5);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* local gconcat = table.concat */
  lc_newclosuretable(L,(lc5 + lc_nextra));
  enum { lc6 = 6 };
  assert((lua_gettop(L) == (lc6 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"concat");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc6 + lc_nextra),6);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* local black_list_m = require("suma_black_list") */
  lua_getfield(L,LUA_ENVIRONINDEX,"require");
  lua_pushliteral(L,"suma_black_list");
  lua_call(L,1,1);
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* ---local suma_c_api= require "ngx_suma_c_api"
   * local _M = {} */
  lc_newclosuretable(L,(lc6 + lc_nextra));
  enum { lc7 = 8 };
  assert((lua_gettop(L) == (lc7 + lc_nextra)));
  lua_newtable(L);
  lua_rawseti(L,(lc7 + lc_nextra),7);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* --_M.HOST="http://192.166.64.22:9530/"
   * _M.AAAGATE    = "http://127.0.0.1:9531/" */
  lua_pushliteral(L,"http://127.0.0.1:9531/");
  lc_getupvalue(L,(lc7 + lc_nextra),0,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"AAAGATE");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* --_M.KEYGATE  = "http://127.0.0.1:8095/"
   * _M.KEYGATE    = "http://127.0.0.1:8095/" */
  lua_pushliteral(L,"http://127.0.0.1:8095/");
  lc_getupvalue(L,(lc7 + lc_nextra),0,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"KEYGATE");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* _M.HOST       = "http://127.0.0.1" */
  lua_pushliteral(L,"http://127.0.0.1");
  lc_getupvalue(L,(lc7 + lc_nextra),0,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"HOST");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* _M.HOST2      = "http://10.254.12.11" */
  lua_pushliteral(L,"http://10.254.12.11");
  lc_getupvalue(L,(lc7 + lc_nextra),0,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"HOST2");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* _M.CRL_HOST   = "http://192.166.64.22:9533/" */
  lua_pushliteral(L,"http://192.166.64.22:9533/");
  lc_getupvalue(L,(lc7 + lc_nextra),0,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"CRL_HOST");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* _M.REDIS_HOST = "127.0.0.1" */
  lua_pushliteral(L,"127.0.0.1");
  lc_getupvalue(L,(lc7 + lc_nextra),0,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"REDIS_HOST");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* _M.g_server_id = nil */
  lua_pushnil(L);
  lc_getupvalue(L,(lc7 + lc_nextra),0,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"g_server_id");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* _M.certificateChain = nil */
  lua_pushnil(L);
  lc_getupvalue(L,(lc7 + lc_nextra),0,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"certificateChain");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* _M.g_selectedAlgorithm = nil */
  lua_pushnil(L);
  lc_getupvalue(L,(lc7 + lc_nextra),0,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"g_selectedAlgorithm");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* local rand = math.random */
  lua_getfield(L,LUA_ENVIRONINDEX,"math");
  lua_pushliteral(L,"random");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) - lc_nextra == 9);
  
  /* local  base_componet_paths    = {} */
  lc_newclosuretable(L,(lc7 + lc_nextra));
  enum { lc8 = 10 };
  assert((lua_gettop(L) == (lc8 + lc_nextra)));
  lua_newtable(L);
  lua_rawseti(L,(lc8 + lc_nextra),8);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* base_componet_paths[1] = _M.HOST  .. ":9801/" */
  lc_getupvalue(L,(lc8 + lc_nextra),1,7);
  lua_pushliteral(L,"HOST");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,":9801/");
  lua_concat(L,2);
  lc_getupvalue(L,(lc8 + lc_nextra),0,8);
  lua_insert(L,-2);
  lua_pushnumber(L,1);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* -- base_componet_paths[2] = _M.HOST  .. ":9802/";
   * -- base_componet_paths[3] = _M.HOST  .. ":9803/";
   * base_componet_paths[2] = _M.HOST2  .. ":9801/" */
  lc_getupvalue(L,(lc8 + lc_nextra),1,7);
  lua_pushliteral(L,"HOST2");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,":9801/");
  lua_concat(L,2);
  lc_getupvalue(L,(lc8 + lc_nextra),0,8);
  lua_insert(L,-2);
  lua_pushnumber(L,2);
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* local  max_client = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) - lc_nextra == 11);
  
  /* _M.get_base_componet_path2 = function () 
   * 	return base_componet_paths[1];
   * end */
  lua_pushvalue(L,(lc8 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_get_base_componet_path2,1);
  lc_getupvalue(L,(lc8 + lc_nextra),1,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"get_base_componet_path2");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 11);
  
  /* _M.get_base_componet_path = function () 
   * 	return base_componet_paths[1];
   * 	-- local rd = rand(100);
   * 	-- if rd < 60 then
   * 	-- 	return  base_componet_paths[1];
   * 	-- end
   * 	-- return  base_componet_paths[2];
   * end */
  lua_pushvalue(L,(lc8 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_get_base_componet_path,1);
  lc_getupvalue(L,(lc8 + lc_nextra),1,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"get_base_componet_path");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 11);
  
  /* local KEY_GATE_WAY_RAW =  _M.KEYGATE .. "kgw/get_key" */
  lc_newclosuretable(L,(lc8 + lc_nextra));
  enum { lc9 = 12 };
  assert((lua_gettop(L) == (lc9 + lc_nextra)));
  lc_getupvalue(L,(lc8 + lc_nextra),1,7);
  lua_pushliteral(L,"KEYGATE");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"kgw/get_key");
  lua_concat(L,2);
  lua_rawseti(L,(lc9 + lc_nextra),9);
  assert(lua_gettop(L) - lc_nextra == 12);
  
  /* _M.key_req_send = function (content, pack)
   * 	local cache_ngx = ngx.shared.ngx_share_dict;
   * 
   * 	local params = {  
   * 	    method     = "POST",
   * 	    ssl_verify = false
   * 	}
   * 	local auth_url   = KEY_GATE_WAY_RAW ;
   * 	params.headers = {};
   * 	params.headers ["Content-Type"]  = "application/json";
   * 	params.body= pack; --cjson.encode(pack);
   * 	
   * 	
   * 	local httpd   	 = http.new() ;
   * 	local rres, rerr = httpd:request_uri(auth_url, params) ;
   * 	-- httpd:set_keepalive(1, 30000)
   * 	if rres ~= nil then
   * 		if nil ~= rres.body then
   * 			local ecek_result = cjson.decode(rres.body);
   * 			
   * 			if ecek_result.status ~= "success" then
   * 				ngx.ctx.status = "contentIDNotFound";
   * 				_M.default_response_print();
   * 				ngx.exit(200);
   * 				return;
   * 			end
   * 			
   * 			local value = cache_ngx:set(content.deviceID .. content.contentIDs[1] .. #content.contentIDs .. ".kgw",  rres.body, 1);  --10min
   * 			--local data  = cjson.decode(rres.body);
   * 			--if data.keyGateWayID ~= nil then
   * 				--ngx.ctx.serverid = data.keyGateWayID;
   * 			--end
   * 			--ngx.log(ngx.ERR , rres.body);
   * 			return rres.body
   * 		end
   * 	end
   * 	ngx.log(ngx.ERR, "err:500 key gate way : " .. rerr);
   * 	ngx.log(ngx.ERR, rres);
   * 	ngx.exit(500);
   * 	return nil;
   * end */
  lua_pushvalue(L,(lc9 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_key_req_send,1);
  lc_getupvalue(L,(lc9 + lc_nextra),2,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"key_req_send");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 12);
  
  /* local template = require("suma_apollo_template") */
  lua_getfield(L,LUA_ENVIRONINDEX,"require");
  lua_pushliteral(L,"suma_apollo_template");
  lua_call(L,1,1);
  assert(lua_gettop(L) - lc_nextra == 13);
  
  /* local cencode = cjson.encode */
  lc_newclosuretable(L,(lc9 + lc_nextra));
  enum { lc20 = 14 };
  assert((lua_gettop(L) == (lc20 + lc_nextra)));
  lc_getupvalue(L,(lc9 + lc_nextra),8,1);
  lua_pushliteral(L,"encode");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc20 + lc_nextra),10);
  assert(lua_gettop(L) - lc_nextra == 14);
  
  /* _M.pack_license = function (node, packer) 
   * 	local cache_ngx = ngx.shared.ngx_share_dict;
   * 	local cache     = cache_ngx:get(node.deviceID .. node.contentIDs[1]  .. #node.contentIDs);
   * 
   * 	-- if cache ~= nil then
   * 	-- 	return cjson.decode(cache);
   * 	-- end
   * 	
   * 	local content = cencode(packer);
   * 	--ngx.log(ngx.ERR, "license = " .. content);
   * 
   * 	local params = {  
   * 	   method     = "POST",
   * 	   ssl_verify = false ,
   * 	   body       = ""
   * 	}
   * 	
   * 	params.headers = {
   * 		["Content-Type"] =  "application/json"
   * 	};
   * 	-- params.headers ["Content-Type"]  = "application/json";
   * 	params.body = content;
   * 	
   * 	local auth_url   = _M.get_base_componet_path() .. "pack_license" ;
   * 	local httpd   	 = http.new() ;
   * 	-- httpd:set_keepalive(1, 30000)
   * 	local rres, rerr = httpd:request_uri(auth_url, params) ;
   * 	--if rres ~= nil then
   * 	-- ngx.log(ngx.ERR, rres.body);
   * 	-- ngx.log(ngx.ERR , params.body);
   * 	local ttt = {};
   * 	if nil ~= rres then
   * 			
   * 		local item = cjson.decode (rres.body)
   * 		if item.code ~= "000" then
   * 			ngx.log(ngx.ERR, "err=>" .. rres.body );
   * 			if ngx.ctx.status == "success" then
   * 				ngx.ctx.status = item.details;
   * 			end
   * 			_M.default_response_print();
   * 			ngx.exit(200);
   * 			return;
   * 		end
   * 
   * 		if item.protectedLicenses ~= nil then
   * 			ttt = item.protectedLicenses;
   * 		else
   * 			ngx.log(ngx.ERR, "pack listence is block1");
   * 			if ngx.ctx.status == "success" then
   * 				ngx.ctx.status = "abort";
   * 			end
   * 			--ngx.log(ngx.ERR, rres.body);
   * 			_M.default_response_print();
   * 			ngx.exit(200);
   * 		end
   * 		-- ttt = item.protectedLicenses;
   * 		-- if (ilen(rres.body) > 30) then
   * 		-- 	ttt = item.protectedLicenses;
   * 		-- else
   * 		-- 	ngx.log(ngx.ERR, "pack listence is block");
   * 		-- 	if ngx.ctx.status == "success" then
   * 		-- 		ngx.ctx.status = "abort";
   * 		-- 	end
   * 		-- 	--ngx.log(ngx.ERR, rres.body);
   * 		-- 	_M.default_response_print();
   * 		-- 	ngx.exit(200);
   * 		-- 	return ttt;
   * 		-- end
   * 			
   * 		--ngx.log(ngx.ERR, "license" .. tostring(item.details));
   * 		cache_ngx:set(node.deviceID .. node.contentIDs[1]  .. #node.contentIDs , cencode(ttt) , 1);
   * 		return ttt
   * 		-- end
   * 	end
   * 	--end
   * 	ngx.log(ngx.ERR, "pack listence is block2");
   * 	if ngx.ctx.status == "success" then
   * 		ngx.ctx.status = "abort";
   * 	end
   * 	_M.default_response_print();
   * 	ngx.exit(200);
   * 	return ttt;
   * end */
  lua_pushvalue(L,(lc20 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_pack_license,1);
  lc_getupvalue(L,(lc20 + lc_nextra),3,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"pack_license");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 14);
  
  /* _M.verify_chain = function (content)
   * 
   * 	local params = {
   * 	   method     = "POST",
   * 	   ssl_verify = false ,
   * 	   body       = ""
   * 	}
   * 	
   * 	params.headers = {
   * 		["Content-Type"] =  "application/json"
   * 	};
   * 	-- params.headers ["Content-Type"]  = "application/json";
   * 	
   * 	local pack = {
   * 		["source"] = content
   * 	};
   *     
   * 	--content = string.gsub(content, "\"", "%\\"");
   * 	params.body= cjson.encode(pack);
   * 	--params.body = [[{"source":"]].. content ..[["}]];
   * 	--ngx.log(ngx.ERR, params.body);
   * 	local auth_url   = _M.get_base_componet_path () .. "verify";
   * 	local httpd   	 = http.new() ;
   * 	-- httpd:set_keepalive(1, 30000)
   * 	local rres, rerr = httpd:request_uri(auth_url, params) ;
   * 	--if rres ~= nil then
   * 	
   * 	if rerr ~= nil then 
   * 		ngx.log(ngx.ERR, "_M.verify_chain::" .. rerr )
   * 	end
   * 	if nil ~= rres then
   * 		--ngx.log(ngx.ERR, "verify" .. rres.body);
   * 		
   * 		-- verify_result.code == "000"
   * 		return rres.body
   * 	end
   * 	--end
   * 	return nil;
   * end */
  lua_pushvalue(L,(lc20 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_verify_chain,1);
  lc_getupvalue(L,(lc20 + lc_nextra),3,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"verify_chain");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 14);
  
  /* _M.verify = function (content)
   * 	local params = {
   * 	   method     = "POST",
   * 	   ssl_verify = false ,
   * 	   body       = ""
   * 	}
   * 	
   * 	params.headers = {
   * 		["Content-Type"] =  "application/json"
   * 	};
   * 	
   * 	
   * 	local pack = {
   * 		["source"] = content
   * 	};
   *     
   * 	--content = string.gsub(content, "\"", "%\\"");
   * 	params.body= cjson.encode(pack);
   * 	--params.body = [[{"source":"]].. content ..[["}]];
   * 	--ngx.log(ngx.ERR, params.body);
   * 	--local auth_url   = "http://192.166.64.22:9555/verify";
   * 	local auth_url   = _M.get_base_componet_path () .. "verifySignature";
   * 	local httpd   	 = http.new() ;
   * 	-- httpd:set_keepalive(1, 30000)
   * 	local rres, rerr = httpd:request_uri(auth_url, params) ;
   * 	--if rres ~= nil then
   * 	if rerr ~= nil then
   * 		ngx.log(ngx.ERR, "verify::" .. rerr )
   * 	end
   * 	if nil ~= rres then
   * 		--ngx.log(ngx.ERR, "verify" .. rres.body);
   * 		return rres.body
   * 	end
   * 	--end
   * 	return nil;
   * end */
  lua_pushvalue(L,(lc20 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_verify,1);
  lc_getupvalue(L,(lc20 + lc_nextra),3,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"verify");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 14);
  
  /* -- local g_header = {}
   * -- g_header ["Content-Type"]  = "application/json";
   * --[[签名--]]
   * _M.signature = function (content)
   * 
   * 
   * 	local params = {
   * 	   method     = "POST",
   * 	   ssl_verify = false ,
   * 	   body       = ""
   * 	}
   * 	
   * 	params.headers = {
   * 		["Content-Type"] =  "application/json"
   * 	};
   * 
   * 	local pack = {
   * 		["source"] = content
   * 	};
   * 	params.body= cjson.encode(pack);
   * 	local auth_url   = _M.get_base_componet_path () .. "sign";
   * 	local httpd   	 = http.new() ;
   * 	local rres, rerr = httpd:request_uri(auth_url, params) ;
   * 	if nil ~= rres then
   * 		return rres.body
   * 	end
   * 	ngx.log(ngx.ERR, "sign error::" .. rerr)
   * 	return nil;
   * end */
  lua_pushvalue(L,(lc20 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_signature,1);
  lc_getupvalue(L,(lc20 + lc_nextra),3,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"signature");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 14);
  
  /* local csignature = _M.signature */
  lc_newclosuretable(L,(lc20 + lc_nextra));
  enum { lc56 = 15 };
  assert((lua_gettop(L) == (lc56 + lc_nextra)));
  lc_getupvalue(L,(lc20 + lc_nextra),3,7);
  lua_pushliteral(L,"signature");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc56 + lc_nextra),11);
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* --[[
   * mock ecek request
   * --]]
   * --_M.g_certificateChain    = {}
   * --_M.g_certificateChain[1] = [[MIIBvDCCAWGgAwIBAgIEEtXjITAKBggqgRzPVQGDdTA0MQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTEWMBQGA1UEAwwNRFJNIFNlcnZlciBDQTAeFw0xOTA1MDUwNzAwMDBaFw0yNDA1MDYwNjU5NTlaMD8xCzAJBgNVBAYMAkNOMRQwEgYDVQQKDAtTdW1hIFZpc2lvbjEaMBgGA1UEAwwRQ0RSTS1QT0MtS01TLVNVTUEwWTATBgcqhkjOPQIBBggqgRzPVQGCLQNCAARL/2NUqsGZK+4vfkdtTogQuMlpxUiG/grZw/88IssvvZvRu4ZNh6QQu2XbupggOj9F7dQevOpA/NhfMZO7eUXOo1YwVDAOBgNVHQ8BAf8EBAMCB4AwFQYDVR0lAQH/BAswCQYHKoEchu8wFzArBgNVHSMEJDAigCCoXjDqV093IYgV+10OcAxe/hMvkFAT2JbGzeCG1j8ONzAKBggqgRzPVQGDdQNJADBGAiEAtSsi8IMaOBV12aVq3/UkvAU+8cC0YUz0Eg5GVd7jTwACIQDkVu8tkLFj5wgLhjHMKf5qaE9FnZG+kryWi9qCdVJ4qg==]] 
   * --_M.g_certificateChain[2] = [[MIIB1TCCAXqgAwIBAgIEPpdMHjAKBggqgRzPVQGDdTAuMQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTEQMA4GA1UEAwwHUm9vdCBDQTAgFw0xOTA1MDUwNzAwMDBaGA8yMDY5MDUwNjA2NTk1OVowNDELMAkGA1UEBgwCQ04xDTALBgNVBAoMBENEVEExFjAUBgNVBAMMDURSTSBTZXJ2ZXIgQ0EwWTATBgcqhkjOPQIBBggqgRzPVQGCLQNCAATBrbIBDT0ZVzSujLTaN+M/6kNFJnBHf+ON4h4Td3ecuqDs3OsX8lzCe2ps3Q9GgkOlTdQvDn0EDc05/Nr93X9Io34wfDApBgNVHQ4EIgQgqF4w6ldPdyGIFftdDnAMXv4TL5BQE9iWxs3ghtY/DjcwDgYDVR0PAQH/BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwKwYDVR0jBCQwIoAg/gShDd110f1FY3fkB+CnCG3gVNkdP8YZv8jbk5SCNNEwCgYIKoEcz1UBg3UDSQAwRgIhAMryOGAga/re2g90+UM9y/tyP4u/TmjP2i1M0BW5vrxiAiEAo/3pXEtWM1z1VbdeV39uGZDmdNSSmLiKhLvz1MvS0hE=]]
   * --未优化
   * _M.get_acc_from_aaa_gate = function (node, contentIds)
   * 	
   * 	local cache_ngx = ngx.shared.ngx_share_dict;
   * 	local cache     = cache_ngx:get(node.deviceID .. "aaa");
   * 	if cache ~= nil then
   * 		return cache;
   * 	end
   * 	local  d = {};
   * 	d.type = "contentRightsRequest";
   * 	d.version =  "1.0";
   * 	d.drmServerID          = _M.g_server_id;
   * 	d.drmClientID          = node.deviceID;
   * 	
   * 	
   * 	local tmp = {};
   * 	for i, v in ipairs(contentIds) do
   * 		tmp[i] = v.contentID;
   * 	end
   * 	d.contentIDs           = tmp;
   * 	d.certificateChain     = _M.certificateChain;
   * 	d.selectedAlgorithm    = _M.g_selectedAlgorithm;
   * 	d.nonce 			   = node.nonce;
   * 	
   * 	
   * 	local str_req = cjson.encode(d) ;
   * 	local n_str   = isub(str_req,1,ilen(str_req)-1);
   * 	local sign    = n_str .. ",\"signature\":\"\"}";
   * 	str_req = n_str .. ",\"signature\":\"".._M.signature(sign).."\"}";
   * 	
   * 	ngx.log(ngx.ERR, "AAA_req" .. str_req);
   * 	
   * 	
   * 	local params = {  
   * 	   method     = "POST",
   * 	   ssl_verify = false
   * 	}
   * 	
   * 	params.headers = {};
   * 	params.headers ["Content-Type"]  = "application/json";
   * 	params.body= str_req ;
   * 	
   * 	local auth_url   = _M.AAAGATE .. "get_rules";
   * 	local httpd   	 = http.new() ;
   * 	local rres, rerr = httpd:request_uri(auth_url, params) ;
   * 	if rres ~= nil then
   * 		if nil ~= rres.body then
   * 			ngx.log(ngx.ERR, "aaa-res=" .. rres.body);
   * 			--local value = cache_ngx:set(content.deviceID, rres.body, 1);  --10min
   * 			--local data  = cjson.decode(rres.body);
   * 			--if data.keyGateWayID ~= nil then
   * 				--ngx.ctx.serverid = data.keyGateWayID;
   * 			--end
   * 			--ngx.log(ngx.ERR , rres.body);
   * 			cache_ngx:set(node.deviceID .. "aaa", rres.body ,1);
   * 			return rres.body
   * 		end
   * 	end
   * 	ngx.log(ngx.ERR, "err:500 aaa gate way" .. rerr);
   * 	--ngx.exit(500);
   * 	
   * 	return ""
   * end */
  lua_pushvalue(L,(lc56 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_get_acc_from_aaa_gate,1);
  lc_getupvalue(L,(lc56 + lc_nextra),4,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"get_acc_from_aaa_gate");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* _M.get_ecek_from_key_gate  = function (node, contentIds) 
   * 	local cache_ngx = ngx.shared.ngx_share_dict;
   * 	local cache     = cache_ngx:get(node.deviceID .. node.contentIDs[1] .. #node.contentIDs .. ".kgw");
   * 	
   * 	-- if cache ~= nil then
   * 	-- 	return cache;
   * 	-- end
   * 	
   * 	local  d = {
   * 		["type"]    =  "keyRequest",
   * 		["version"] =  "1.0" ,
   * 		["drmServerID"] = _M.g_server_id,
   * 		["contentIDs"]  = contentIds,
   * 		["certificateChain"] = _M.certificateChain,
   * 		["drmClientCertificate"] = node.certificateChain[1],
   * 		["selectedAlgorithm"]    = _M.g_selectedAlgorithm,
   * 		["nonce"] = node.nonce
   * 	};
   * 	-- d.type = "keyRequest";
   * 	-- d.version =  "1.0";
   * 	-- d.drmServerID          = _M.g_server_id;
   * 	-- d.contentIDs           = contentIds;
   * 	-- d.certificateChain     = _M.certificateChain;
   * 	-- d.drmClientCertificate = node.certificateChain[1];
   * 	-- d.selectedAlgorithm    = _M.g_selectedAlgorithm;
   * 	-- d.nonce 			   = node.nonce;
   * 	-------------------------------减少relloc的次数
   * 	
   * 	
   * 	local str_req = cjson.encode(d) ;
   * 	
   * 	ngx.log(ngx.ERR, str_req);
   * 	local n_str   = isub(str_req,1,ilen(str_req)-1);
   * 	local sign    = n_str .. ",\"signature\":\"\"}";
   * 	
   * 	local __sign = csignature(sign);
   * 	if __sign == nil then
   * 		ngx.log(ngx.ERR, "\n\n[error] __sign error \n\n")
   * 		ngx.exit(500);
   * 		return;
   * 	end
   * 	
   * 	str_req = gconcat({ n_str , ",\"signature\":\"", __sign, "\"}"});
   * 	local str = _M.key_req_send (node, str_req);
   * 	-- ngx.log(ngx.ERR, "ecek" .. str);
   * 	return str;
   * end */
  lua_pushvalue(L,(lc56 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_get_ecek_from_key_gate,1);
  lc_getupvalue(L,(lc56 + lc_nextra),4,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"get_ecek_from_key_gate");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 15);
  
  /* local __exit = ngx.exit */
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"exit");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) - lc_nextra == 16);
  
  /* local SIZE_TIME_CORRECT = 3600 */
  lua_pushnumber(L,3600);
  assert(lua_gettop(L) - lc_nextra == 17);
  
  /* local NEXT_DAY_SEC      = 86400 */
  lc_newclosuretable(L,(lc56 + lc_nextra));
  enum { lc71 = 18 };
  assert((lua_gettop(L) == (lc71 + lc_nextra)));
  lua_pushnumber(L,86400);
  lua_rawseti(L,(lc71 + lc_nextra),12);
  assert(lua_gettop(L) - lc_nextra == 18);
  
  /* --- 请求content id [ok] --防止realloc优化
   * _M.get_content_id_from_req = function (node) 
   * 	local eax = nil;
   * 	if ngx.ctx.contentID ~= nil then
   * 		eax = ngx.ctx.contentID;
   * 		-- ngx.log(ngx.ERR, ngx.ctx.contentID)
   * 	else 
   * 		eax = node.contentIDs;
   * 	end
   * 	
   * 	local contents_ids = {};
   * 	local time_curr = ngx.time() .. "";
   * 	local time_end  = (time_curr + NEXT_DAY_SEC ).. ""; -- NEXT_DAY_SEC
   * 	for k, v in ipairs(eax) do
   * 		--if v ~= nil then
   * 			--防止realloc优化
   * 			local oneContent = {
   * 				["contentID"] = "",
   * 				["startTime"] = "",
   * 				["endTime"]   = ""
   * 			};
   * 			oneContent.contentID = v;
   * 			oneContent.startTime = time_curr;
   * 			oneContent.endTime   = time_end;
   * 			contents_ids[k]      = oneContent;
   * 		--end
   * 	end
   * 	return contents_ids;
   * end */
  lua_pushvalue(L,(lc71 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_get_content_id_from_req,1);
  lc_getupvalue(L,(lc71 + lc_nextra),5,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"get_content_id_from_req");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 18);
  
  /* --- 请求时间 [ok]
   * _M.check_time_correct = function (check_time) 
   * 	return true;
   * 	-- if not check_time then
   * 	-- 	return false
   * 	-- end
   * 	
   * 	-- local time_t = ngx.time()
   * 	
   * 	-- if (check_time > time_t  - SIZE_TIME_CORRECT) and
   * 	--    ( check_time < time_t + SIZE_TIME_CORRECT) then
   * 	-- 	return true
   * 	-- end
   * 	-- return false
   * end */
  lua_pushcfunction(L,lcf1__M_check_time_correct);
  lc_getupvalue(L,(lc71 + lc_nextra),5,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"check_time_correct");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 18);
  
  /* local cache_ngx = ngx.shared.ngx_share_dict */
  lc_newclosuretable(L,(lc71 + lc_nextra));
  enum { lc76 = 19 };
  assert((lua_gettop(L) == (lc76 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"shared");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"ngx_share_dict");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc76 + lc_nextra),13);
  assert(lua_gettop(L) - lc_nextra == 19);
  
  /* ----
   * ---- 距离优化
   * _M.get_share_dict_data = function (key) 
   *     return  cache_ngx:get(key);
   * end */
  lua_pushvalue(L,(lc76 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_get_share_dict_data,1);
  lc_getupvalue(L,(lc76 + lc_nextra),6,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"get_share_dict_data");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 19);
  
  /* local func_get_share_dict_data = _M.get_share_dict_data */
  lc_newclosuretable(L,(lc76 + lc_nextra));
  enum { lc78 = 20 };
  assert((lua_gettop(L) == (lc78 + lc_nextra)));
  lc_getupvalue(L,(lc76 + lc_nextra),6,7);
  lua_pushliteral(L,"get_share_dict_data");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc78 + lc_nextra),14);
  assert(lua_gettop(L) - lc_nextra == 20);
  
  /* local cert  = require("suma_cert_module") */
  lua_getfield(L,LUA_ENVIRONINDEX,"require");
  lua_pushliteral(L,"suma_cert_module");
  lua_call(L,1,1);
  assert(lua_gettop(L) - lc_nextra == 21);
  
  /* local igsub = string.gsub */
  lc_newclosuretable(L,(lc78 + lc_nextra));
  enum { lc79 = 22 };
  assert((lua_gettop(L) == (lc79 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"string");
  lua_pushliteral(L,"gsub");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc79 + lc_nextra),15);
  assert(lua_gettop(L) - lc_nextra == 22);
  
  /* local mverify = _M.verify */
  lc_newclosuretable(L,(lc79 + lc_nextra));
  enum { lc80 = 23 };
  assert((lua_gettop(L) == (lc80 + lc_nextra)));
  lc_getupvalue(L,(lc79 + lc_nextra),8,7);
  lua_pushliteral(L,"verify");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc80 + lc_nextra),16);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* _M.default_response_print = function () 
   * 	if not ngx.ctx.nonce then
   * 		ngx.ctx.nonce     = "";
   * 	end
   * 	
   * 	if not ngx.ctx.status then
   * 		ngx.ctx.status   = "malformedRequest";
   * 	end
   * 	
   * 	if not ngx.ctx.deviceID then
   * 		ngx.ctx.deviceID = "";
   * 	end
   * 	
   * 	-----relloc 优化
   * 	local result = {0,0,0,0,0,0,0,0,0,0,0} ;
   * 	result[1] = '{"type":"licenseResponse","version":"2.0","status":"';
   * 	result[2] = ngx.ctx.status
   * 	result[3] = '","selectedAlgorithm":"KMSProfile1","responseTime":"';
   * 	result[4] = ngx.time() ;
   * 	result[5] = '","deviceID":"'
   * 	result[6] = ngx.ctx.deviceID ;
   * 	result[7] = '","drmServerID":"';
   * 	result[8] = _M.g_server_id;
   * 	result[9] =  '","nonce":"';
   * 	result[10] = ngx.ctx.nonce;
   * 	result[11] ='","protectedLicenses":[],"certificateChain":[],"signature":""}'
   * 	
   * 	--local str_req = test ;-- cjson.encode(res) ;
   * 	--local str_req = cjson.encode(res) 
   * 	local  result_str = gconcat(result)
   * 	ngx.log(ngx.ERR, "resp::err" .. result_str);
   * 	ngx.say(result_str);
   * 	ngx.exit(200);
   * end */
  lua_pushvalue(L,(lc80 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_default_response_print,1);
  lc_getupvalue(L,(lc80 + lc_nextra),9,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"default_response_print");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* --crl check 未优化
   * _M.crl_check = function (deviceId)
   * 	local key = "suma_crl_" ..  deviceId
   * 	local redis = require("suma_apollo_redis") ;
   * 	local red   = redis:new();
   * 	
   * 	local ok, err = red:connect(_M.REDIS_HOST,  6379) ;
   * 	red:auth("redis");
   * 	if not ok then   ---连接失败正常访问
   * 		ngx.log(ngx.ERR, "connect to redis error : " , err)
   * 		red:close();
   * 		return ;
   * 	end  
   * 	----请求redis
   * 	local res = red:get(key) ;
   * 	red:close();
   * 	
   * 	-- ngx.log(ngx.ERR, "cc=" .. tostring(res))
   *  	if tostring(res) == "userdata: NULL" then --代表 CRL 服务过期清空
   * 		---开始请求
   * 		-- ngx.log(ngx.ERR, "gogogo");
   * 		
   * 		local params = {
   * 		   method     = "POST",
   * 		   ssl_verify = false
   * 		}
   * 		params.headers = {};
   * 		params.headers ["Content-Type"]  = "application/json";
   * 		
   * 		
   * 		local pack = {};
   * 		--content = isub (content,1,ilen(content)-2);
   * 		--content = string.gsub(content, "%\\%/", "%/");
   * 		pack.deviceID= deviceId;
   * 		pack.cert    = ngx.ctx.cert;
   * 		
   * 		params.body= cjson.encode(pack);
   * 		
   * 		local auth_url   = _M.CRL_HOST .. "verify_crl";
   * 		local httpd   	 = http.new() ;
   * 		local rres, rerr = httpd:request_uri(auth_url, params) ;
   * 		--if rres ~= nil then
   * 		if rerr then
   * 			ngx.log(ngx.ERR, rerr)
   * 		end
   * 		if nil ~= rres then
   * 			ngx.log(ngx.ERR, "crl =" .. rres.body);
   * 			local data = cjson.decode(rres.body);
   * 			
   * 			if data.code == 2 then
   * 				ngx.log(ngx.ERR, "crl result2 block");
   * 				
   * 				-- return rres.body
   * 				if ngx.ctx.status == "success" then
   * 					ngx.ctx.status = "abort";
   * 				end
   * 				_M.default_response_print();
   * 				ngx.log(ngx.ERR, "crl block request");
   * 				ngx.exit(200);
   * 				return ;
   * 			end
   * 		end
   * 		--end
   * 		-- return nil;
   * 		return;
   * 		
   * 	end
   * 	
   * 	if res == 2 then
   * 		if ngx.ctx.status == "success" then
   * 			ngx.ctx.status = "abort";
   * 		end
   * 		_M.default_response_print();
   * 		ngx.log(ngx.ERR, "crl block request");
   * 		ngx.exit(200);
   * 		return ;
   * 	end
   * end */
  lua_pushvalue(L,(lc80 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_crl_check,1);
  lc_getupvalue(L,(lc80 + lc_nextra),9,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"crl_check");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* -- ocsp 处理
   * -- reids   suma_ocsp_ri cache 5分钟周期失效
   * -- 请求缓存 -> 回源redis -> 存入缓存
   * _M.ocsp_get = function ()
   * 	local key = "suma_ocsp_ri"
   * 	
   * 	local exists = func_get_share_dict_data(key);
   * 	
   * 	if exists ~= nil then
   * 		return exists
   * 	end
   * 	local cache_ngx   = ngx.shared.ngx_share_dict;
   * 	local newval, err = cache_ngx:incr(key .. ".lock",1, 0, 1); --- 自悬锁
   * 	if tonumber(newval) ~= 1 then
   * 		ngx.sleep(0.1) ; --- sleep 100ms timeout 
   * 		return func_get_share_dict_data(key);
   * 	end
   * 	
   * 	local redis = require("suma_apollo_redis") ;
   * 	local red   = redis:new();
   * 	
   * 	local ok, err = red:connect(_M.REDIS_HOST,  6379) ;
   * 	red:auth("redis");
   * 	if not ok then  
   * 		ngx.log(ngx.ERR, "connect to redis error : " , err)
   * 		red:close();
   * 		return "";
   * 	end  
   * 	
   * 	----请求redis
   * 	local res = red:get(key) ;
   * 	red:close();
   * 	if res ~= nil then
   * 		local cache_ngx = ngx.shared.ngx_share_dict;
   * 		local value     = cache_ngx:set(key, res, 300);
   * 		return res
   * 	end
   * 	return "";
   * end */
  lua_pushvalue(L,(lc80 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_ocsp_get,1);
  lc_getupvalue(L,(lc80 + lc_nextra),9,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"ocsp_get");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 23);
  
  /* local bodyReader = ngx.req.read_body */
  lc_newclosuretable(L,(lc80 + lc_nextra));
  enum { lc120 = 24 };
  assert((lua_gettop(L) == (lc120 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"ngx");
  lua_pushliteral(L,"req");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushliteral(L,"read_body");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_rawseti(L,(lc120 + lc_nextra),17);
  assert(lua_gettop(L) - lc_nextra == 24);
  
  /* _M.DRM_SYSTEM_ID = {
   * 	[ "61941095315515465232184672216011011419644" ] = function (param) 
   * 		---china drm
   * 		ngx.log(ngx.ERR, "china drm rrotate");
   * 		if param.contentID ~= nil then
   * 			if ngx.ctx.contentID == nil then
   * 				ngx.ctx.contentID = {};
   * 			end
   * 			ngx.ctx.contentID[#ngx.ctx.contentID + 1] = param.contentID;
   * 			ngx.log(ngx.ERR, "add contentID=" .. param.contentID);
   * 			return true;
   * 		end
   * 		return false
   * 	end
   * } */
  lua_createtable(L,0,1);
  lua_pushliteral(L,"61941095315515465232184672216011011419644");
  lua_pushcfunction(L,lcf128);
  lua_rawset(L,-3);
  lc_getupvalue(L,(lc120 + lc_nextra),10,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"DRM_SYSTEM_ID");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 24);
  
  /* function split(szFullString, szSeparator)
   * 	local nFindStartIndex = 1
   * 	local nSplitIndex = 1
   * 	local nSplitArray = {}
   * 	while true do
   * 	   local nFindLastIndex = string.find(szFullString, szSeparator, nFindStartIndex)
   * 	   if not nFindLastIndex then
   * 		nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, string.len(szFullString))
   * 		break
   * 	   end
   * 	   nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, nFindLastIndex - 1)
   * 	   nFindStartIndex = nFindLastIndex + string.len(szSeparator)
   * 	   nSplitIndex = nSplitIndex + 1
   * 	end
   * 	return nSplitArray
   * end */
  lua_pushcfunction(L,lcf1_split);
  lua_setfield(L,LUA_ENVIRONINDEX,"split");
  assert(lua_gettop(L) - lc_nextra == 24);
  
  /* _M.pssh_check = function (contentId)
   * 	local dd 	   = contentId;
   * 	local byte_xor = string.byte;
   * 	local obj      = ngx.decode_base64(dd);
   * 	
   * 	local is_m3u8  = string.char(byte_xor(obj,1,8));
   * 	if "#EXT-X-K" ==  is_m3u8 then
   * 		ngx.log(ngx.ERR, " m3u8 => mp4dash");
   * 		local test2 = split (obj, ",");
   * 		local look_up_next = false;
   * 		for i, v in ipairs(test2) do
   * 			if look_up_next then
   * 				ngx.log(ngx.ERR, "pssh data=:" .. v);
   * 				obj = ngx.decode_base64(string.sub(v, 1, #v-1));
   * 				look_up_next = false;
   * 			end
   * 			
   * 			if v == 'URI="data:text/plain;base64' then
   * 				look_up_next = true;
   * 			end
   * 		end
   * 		
   * 		if obj == nil then
   * 			return false;
   * 		end
   * 	end
   * 	-- if (string.byte(obj, 33, 34) == 0x7b) and -- {
   * 	--    (string.byte(obj, tail - 1 , tail) == 0x7d) then -- }
   * 	-- 	-- ngx.log(ngx.ERR, "is a validate JSON");
   * 	-- else
   * 	-- 	return false;
   * 	-- end
   * 	-- ngx.log(ngx.ERR , string.byte(obj,1,#obj));
   *  --    ngx.log(ngx.ERR, string.byte(obj,1,4));      -- Size 4字节
   *  --    ngx.log(ngx.ERR, string.byte(obj,5,8));      -- Type 4字节 0x70 73 73 68
   *  --    ngx.log(ngx.ERR, string.byte(obj,9,10));     -- version 1字节
   *  --    ngx.log(ngx.ERR, string.byte(obj,11,12));    -- Flags 3字节
   *  --    ngx.log(ngx.ERR, string.byte(obj,13,28));    -- SystemId 16字节
   * 	-- ngx.log(ngx.ERR, string.byte(obj,29,32));    -- dataSize 4字节
   * 	--类型不对
   * 	
   * 	local  sType   = string.char(byte_xor(obj,5,8)); -- Type 4字节 0x70 73 73 68
   * 	-- ngx.log(ngx.ERR, "pssh = " .. sType);
   * 	if sType ~= "pssh" then  
   * 		return false;
   * 	end
   * 	
   * 	local tail = #obj;
   * 	
   * 	----因为截取的是指针，我们必须把指针转换成字符串
   * 	local buffer = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
   * 	
   * 	for i=1,16,1 do
   * 	   buffer [i] = byte_xor(obj,i+12, i+13);
   * 	end
   * 	
   * 	local system_id = gconcat(buffer);
   * 	-- ngx.log(ngx.ERR, "system_id=" .. system_id);
   * 	----如果不在drm列表内说明没有注册的DRM ID
   * 	if _M.DRM_SYSTEM_ID[system_id] ~= nil then
   * 		local pssh_data = string.char(byte_xor(obj,33,tail));
   * 		local node = nil ;
   * 		-- ngx.log(ngx.ERR, pssh_data)
   * 		pcall(function ()
   * 			node = c_decode(pssh_data);
   * 		end);
   * 		-- ngx.log(ngx.ERR, "node=" .. cjson.encode(node));
   * 		if (node ~= nil) then
   * 			return _M.DRM_SYSTEM_ID[system_id] (node);
   * 		end
   * 	end
   * 	return false;
   * end */
  lua_pushvalue(L,(lc120 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_pssh_check,1);
  lc_getupvalue(L,(lc120 + lc_nextra),10,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"pssh_check");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 24);
  
  /* _M.handle = function ()
   * 	
   * 	-- ngx.exit(200);
   * 	-- local args = ngx.req.get_uri_args();
   * 	
   * 	---测试字段
   * 	-- if args and args.test ~= nil then
   * 	-- 	ngx.ctx.test = args.test;
   * 	-- end
   * 	
   * 	ngx.ctx.status = "success"
   * 
   * 	if _M.g_server_id == nil then
   * 		_M.certificateChain    = c_decode(func_get_share_dict_data("CertificateChain0"));
   * 		_M.g_server_id		   = func_get_share_dict_data("GetKeyID0");
   * 		_M.g_selectedAlgorithm = func_get_share_dict_data("GetAlgorithm0");
   * 	end
   * ---force request body 
   * ---this was harmful performance
   * 	bodyReader();
   * 	
   * 	local body_str = ngx.req.get_body_data();
   * 	
   * 	if body_str == nil then
   * 		local file_name = ngx.req.get_body_file()
   * 		if file_name then
   * 			body_str = get_file(file_name)
   * 		end
   * 		
   * 		if nil == body_str then
   * 			ngx.exit(ngx.HTTP_BAD_REQUEST);
   * 			return;
   * 		end
   * 	end
   * 
   * 	ngx.log(ngx.ERR, "request body" .. body_str);
   * 	local node  = nil;
   * 	local invalidate =  pcall(function () 
   * 		node = c_decode(body_str);
   * 	end);
   * 	
   * 
   * 	if node == nil then
   * 		if ngx.ctx.status == "success" then
   * 			ngx.ctx.status = "malformedRequest";
   * 		end
   * 		_M.default_response_print();
   * 		ngx.exit(200);
   * 		return;
   * 	end
   * 	
   * 	-- if not ngx.ctx.test then
   * 	ngx.ctx.deviceID = node.deviceID;
   * 	
   * 	if not node.deviceID then
   * 		ngx.ctx.status = "abort";
   * 		_M.default_response_print();
   * 		ngx.exit(200);
   * 	end
   * 	
   * 	ngx.ctx.nonce    = node.nonce;
   * 	
   * 	if (not node.nonce) or (node.nonce == "") then
   * 		ngx.ctx.status = "abort";
   * 		_M.default_response_print();
   * 		ngx.exit(200);
   * 	end
   * 	
   * 	if (not node.version) or (node.version ~= "2.0") then
   * 		--TODO default 
   * 		if ngx.ctx.status == "success" then
   * 			ngx.ctx.status = "versionNotSupported";
   * 		end
   * 		_M.default_response_print();
   * 		ngx.exit(200);
   * 	end
   * 	
   * 	if (not node.type) or (node.type ~= "licenseRequest") then
   * 		--TODO default 
   * 		if ngx.ctx.status == "success" then
   * 			ngx.ctx.status = "typeNotSupported";
   * 		end
   * 		_M.default_response_print();
   * 		ngx.exit(200);
   * 	end
   * 	
   * 	if (not node.contentIDs) then
   * 		ngx.ctx.status = "contentIDNotFound";
   * 		_M.default_response_print();
   * 		ngx.exit(200);
   * 	end
   * 	
   * 	----多个content ID是PSSHbox 的情况
   * 	----需要多次处理替换原有的ContentID
   * 	-- node.contentIDs[1] = [[AAAAo3Bzc2gAAAAAPV5tNZuaQei4Q908bnLELAAAAIN7InZlcnNpb24iOiJWMS4wIiwiY29udGVudElEIjoiTVRBd01EQXhNREV5TXpRMU5qYzRPUT09Iiwia2lkcyI6WyJOelpsTnpSaU56YzBaREF4TkRSaU1XSXhPRE5tTlRnME1ERTRabVEzTVRrPSJdLCJlbnNjaGVtYSI6ImNlbmMifQ]]
   * 	-- node.contentIDs[2] = [[AAAAtXBzc2gAAAAAPV5tNZuaQei4Q908bnLELAAAAJV7InZlcnNpb24iOiJWMS4wIiwiY29udGVudElEIjoiY0c5cGRXNWlkbUZ6WkdabmFHdHgiLCJraWRzIjpbIk56WmxOelJpTnpjMFpEQXhORFJpTVdJeE9ETm1OVGcwTURFNFptUTNNVGs9Il0sImVuc2NoZW1hIjoic200YyIsImV4dGVuc2lvbnMiOiJzdHJpbmcifQ]]
   * 	for i=1,#node.contentIDs,1 do
   * 	  _M.pssh_check(node.contentIDs[i]);
   * 	end
   * 	
   * 	if (not node.supportedAlgorithms)  or (node.supportedAlgorithms[1] ~= "KMSProfile1") then
   * 		ngx.ctx.status = "abort";
   * 		_M.default_response_print();
   * 		ngx.exit(200);
   * 	end
   * 	
   * 	if (not node.certificateChain ) or (#node.certificateChain < 2) then
   * 		ngx.ctx.status = "invalidCertificateChain";
   * 		_M.default_response_print();
   * 		ngx.exit(200);
   * 	end
   * 	
   * 	local  verify_result = nil;
   * 	if func_get_share_dict_data(ngx.ctx.deviceID .. ".chain") == nil then
   * 		----校验客户端的证书链
   * 		verify_result = _M.verify_chain(body_str);
   * 		if string.find(verify_result , "000") ~= nil  then
   * 			local cache_ngx = ngx.shared.ngx_share_dict;
   * 			cache_ngx:set(node.deviceID .. ".chain" , 1);
   * 		end
   * 	else
   * 		verify_result = mverify (body_str);
   * 	end
   * 	
   * 	if (not verify_result) then
   * 		-- ngx.log(ngx.ERR, "error::failed..")
   * 		if ngx.ctx.status == "success" then
   * 			ngx.ctx.status = "abort";
   * 		end
   * 		_M.default_response_print();
   * 		ngx.exit(200);
   * 	end
   * 	
   * 	verify_result = cjson.decode(verify_result);
   * 	
   * 	if verify_result.code ~= "000" then
   * 		--ngx.log(ngx.ERR, "verify is block");
   * 		if ngx.ctx.status == "success" then
   * 			ngx.ctx.status = verify_result.details;
   * 		end
   * 		_M.default_response_print();
   * 		ngx.exit(200);
   * 	end
   * 
   * 	------------------------------------------------------------
   * 	-- local OLD1 = node.deviceID;
   * 	-- local OLD2 = node.nonce;
   * 	-- -- node.deviceID = "RND_" .. math.random(10000);
   * 	-- node.nonce    = node.deviceID;
   * 	
   * 	------------------------------------------------------------
   * 	----- crl 
   * 	-- if node.certificateChain then
   * 	-- 	ngx.ctx.cert = node.certificateChain[1];
   * 	-- 	_M.crl_check(node.deviceID)
   * 	-- end
   * 
   * 	-- suma_crl_deviceID
   * 	-- if not black_list_m.forbid(node.deviceID) then
   * 	-- 	if ngx.ctx.status == "success" then
   * 	-- 		ngx.ctx.status = "accessDenied";
   * 	-- 	end
   * 	-- 	ngx.log(ngx.ERR, "black_list block");
   * 	-- 	_M.default_response_print();
   * 	-- 	ngx.exit(200);
   * 	-- end
   * 	
   * 	-- if (_M.check_time_correct(tonumber(node.requestTime)) == false) then
   * 	-- 	ngx.log(ngx.ERR, "request time is not invalidate");
   * 	-- 	if ngx.ctx.status == "success" then
   * 	-- 		ngx.ctx.status = "deviceTimeError";
   * 	-- 	end
   * 	-- end
   * 	
   * 	-- if  ngx.ctx.test then
   * 	-- 	local cache_ngx = ngx.shared.ngx_share_dict;
   * 	-- 	local cache     = cache_ngx:get(node.nonce);
   * 	-- 	if cache ~= nil then
   * 	-- 		ngx.ctx.status = "abort";
   * 	-- 		_M.default_response_print();
   * 	-- 		ngx.exit(200);
   * 	-- 		ngx.log(ngx.ERR, "this is nonce id block.");
   * 	-- 		return cache;
   * 	-- 	end
   * 	-- 	cache_ngx:set(node.nonce, 1);
   * 	-- end
   * 	--local template  = require "resty.template"
   * 	--local render_ri = template.suma_ri_response;
   * 	
   * 
   * 	local contentIds = _M.get_content_id_from_req(node);
   * 	local ecek       = _M.get_ecek_from_key_gate (node, contentIds);
   * 	--ngx.log(ngx.ERR, "ecek=" .. ecek);
   * 	if ecek == nil then
   * 		ngx.log(ngx.ERR, "key gate way is block");
   * 		if ngx.ctx.status == "success" then
   * 			ngx.ctx.status = "contentIDNotFound";
   * 		end
   * 		_M.default_response_print();
   * 		ngx.exit(200);
   * 		return;
   * 	end
   * 	
   * 	-- local aaa = _M.get_acc_from_aaa_gate(node, contentIds);
   * 	-- if not aaa then
   * 	-- 	ngx.log(ngx.ERR, "aaa connect failed");
   * 	-- 	ngx.exit(500);
   * 	-- 	return;
   * 	-- end
   * 	
   * 	-- local aaa_result = cjson.decode(ecek);
   * 	
   * 	-- if aaa_result.status ~= "success" then
   * 	-- 	ngx.ctx.status = "abort";
   * 	-- 	_M.default_response_print();
   * 	-- 	ngx.exit(200);
   * 	-- 	ngx.log(ngx.ERR, "aaa failed");
   * 	-- 	return;
   * 	-- end
   * 	
   * 	--[[
   * 	if eax(ecek) ~= '0' then
   * 		ngx.log(ngx.ERR, "key gate way is block");
   * 		ngx.exit(500);
   * 	end
   * 	--]]
   * 	--[[if node.deviceID == nil then
   * 		ngx.log(ngx.ERR, "key gate way is block");
   * 		ngx.exit(500);
   * 		return;
   * 	end
   * 	--]]
   * 		
   * 	--if  not license then
   * 		--ngx.log(ngx.ERR, "ecek" .. ecek);
   * 		--ngx.log(ngx.ERR, "deviceId" ..  node.deviceID);
   * 	--end
   * 	---------------------------------------------------
   * 	---relloc 
   * 	local packer = {
   * 		["drmClientCertificate"] = "",
   * 		["keyResponse"] = "",
   * 		["deviceID"] = ""
   * 	};
   * 	
   * 		---test
   * 	--local  test = [[{"type":"keyResponse","version":"1.0","keyGateWayID":"K5gvdvIqkO15/VyiWA9D1laOmZrLj21YhV+x6iCMw24=","nonce":"kuYqz45291w7hpRnRBONJJOW2UY=","status":"success","selectedAlgorithm":"KMSProfile1","certificateChain":["MIIBujCCAWGgAwIBAgIEIHwhZzAKBggqgRzPVQGDdTA0MQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTEWMBQGA1UEAwwNRFJNIFNlcnZlciBDQTAeFw0xOTA1MDUwNzAwMDBaFw0yNDA1MDYwNjU5NTlaMD8xCzAJBgNVBAYMAkNOMRQwEgYDVQQKDAtTdW1hIFZpc2lvbjEaMBgGA1UEAwwRQ0RSTS1QT0MtS0dXLVNVTUEwWTATBgcqhkjOPQIBBggqgRzPVQGCLQNCAAS+JIbKf7puoYnvCqzmpbV3gax9AdVaLPAMBEWunR7SbfIQO9+yy5t7FKxdgsnAg76OdDTbt3X+TDDeysqmjWc7o1YwVDAOBgNVHQ8BAf8EBAMCB4AwFQYDVR0lAQH/BAswCQYHKoEchu8wGDArBgNVHSMEJDAigCCoXjDqV093IYgV+10OcAxe/hMvkFAT2JbGzeCG1j8ONzAKBggqgRzPVQGDdQNHADBEAiA22S6prBdSVjhg31fFrACZ/wyftPg1YL9f240DEOPrSQIgQ9HXrmK1weF+heckOHdVEP+2TFmJHMvrcVAKzdRMw4g=","MIIB1TCCAXqgAwIBAgIEPpdMHjAKBggqgRzPVQGDdTAuMQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTEQMA4GA1UEAwwHUm9vdCBDQTAgFw0xOTA1MDUwNzAwMDBaGA8yMDY5MDUwNjA2NTk1OVowNDELMAkGA1UEBgwCQ04xDTALBgNVBAoMBENEVEExFjAUBgNVBAMMDURSTSBTZXJ2ZXIgQ0EwWTATBgcqhkjOPQIBBggqgRzPVQGCLQNCAATBrbIBDT0ZVzSujLTaN+M/6kNFJnBHf+ON4h4Td3ecuqDs3OsX8lzCe2ps3Q9GgkOlTdQvDn0EDc05/Nr93X9Io34wfDApBgNVHQ4EIgQgqF4w6ldPdyGIFftdDnAMXv4TL5BQE9iWxs3ghtY/DjcwDgYDVR0PAQH/BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwKwYDVR0jBCQwIoAg/gShDd110f1FY3fkB+CnCG3gVNkdP8YZv8jbk5SCNNEwCgYIKoEcz1UBg3UDSQAwRgIhAMryOGAga/re2g90+UM9y/tyP4u/TmjP2i1M0BW5vrxiAiEAo/3pXEtWM1z1VbdeV39uGZDmdNSSmLiKhLvz1MvS0hE="],"signature":"BbXYFe1s572L6dndaE+zyXDtUhrZTNGX64sIOSAJc7MghPTvRC71DqbEpohUjtcBELKBTMqQoeXNaPxvIdEJhw==","cekInfos":[{"contentID":"Um90YUtleUxpdmVTbm0=","sessionKeyID":"uAXDMxEgi77XiyHDJ8QFrA==","encSessionKey":"BJgd3JdXsSooY7T/5GIZitBLM7i+FLf00U6ItsJkDcRNlYgiZUSghWqBNMmrCEBGr9bOUwdQ6Qjz/GDT3iItlINba4DWjRWRWG3CHykBqQw8gl8AbKO9zcyQyxSfs18OyZtnH/SzKIKx6zYdHlXR+p4=","encCEKs":[{"cekID":"YExCgSKD3uniX9sNlLWiRw==","encCEK":"9i2vJxTxzM9USBhVDVwJCA=="},{"cekID":"EGCw+DFXrkfLhPmpqIfhYw==","encCEK":"RAMVDiNVhswF1KUz+8LcDA=="},{"cekID":"RtbY6XyzOh32BdUMLU4Ipw==","encCEK":"5QKH38bOcEGq9bnmcBb2OQ=="}],"contentRules":"BQEEXxekxAIEce+FRAQEAAAAluAEX1X1YOEEX1X3Ig=="}]}]]
   * 	
   * 	packer.drmClientCertificate = node.certificateChain[1];
   * 	packer.keyResponse          = ecek;
   * 	packer.deviceID             = node.deviceID;
   * 	if aaa ~= nil then
   * 		packer.aaaResponse          = aaa;
   * 	end
   * 	local license = _M.pack_license(node, packer);
   * 
   * 	--[[
   * 	local license    = suma_c_api.ngx_suma_pack_license(
   * 		node.deviceID,
   * 		ecek
   * 	);
   * 
   * 	if  not license then
   * 		ngx.log(ngx.ERR, "ecek" .. ecek);
   * 		ngx.log(ngx.ERR, "deviceId" ..  node.deviceID);
   * 		ngx.exit(500);
   * 		return;
   * 	end
   * 	--]]
   * 	
   * 	---relloc 
   * 	local res  = {
   * 		["version"] = 1,
   * 		["type"]    = 1,
   * 		["status"]  = 1,
   * 		["protectedLicenses"] = 1,
   * 		["responseTime"] = 1,
   * 		["certificateChain"] = 1,
   * 		["drmServerID"] = 1,
   * 		["selectedAlgorithm"] = 1,
   * 		["deviceID"] = 1,
   * 		["nonce"] = 1
   *  	};
   * 	res.version = node.version;
   * 	res.type    = "licenseResponse";
   * 	res.status  = ngx.ctx.status  ;
   * 	res.protectedLicenses = license;
   * 	res.responseTime      = ngx.time().. "";
   * 	res.certificateChain  = _M.certificateChain;
   * 	res.drmServerID		  = _M.g_server_id;
   * 	res.selectedAlgorithm = _M.g_selectedAlgorithm;
   * 	res.deviceID          = node.deviceID;
   * 	res.nonce             = node.nonce;
   * 	
   * 	--local test = '{"type":"licenseResponse","version":"2.0","status":"success","selectedAlgorithm":"KMSProfile1","responseTime":"1599188389","deviceID":"zdx/5YDHb5pIzqbNzxA1b1CmUbigqNoeaGl4yz8IN8g=","drmServerID":"/XHjg6n6nbVknQCOiQp4DbDDFCIAt1ZaTMPi59OQlvc=","nonce":"AAECAwQFBgcICQoLDA0ODxAR","protectedLicenses":[{"licenseID":"X1Gtpex1fm8=","license":"AAAADgJfUa2l7HV+bwtfUa2lAQEAQw5Sb3RhS2V5TGl2ZVNubQMQBPYUg58owlPhz/xhS2qQhBDgdKOLZVj4HpgM09AKTIgmECSqk6h4x7NbBEvnPhKEae8CAgAhAM3cf+WAx2+aSM6mzc8QNW9QplG4oKjaHmhpeMs/CDfIAwMAqBIAcQQazDChM1ioCBeMOL/fZXiI2KKpDlIArnvxRRh4RyrHYoI/d2nEZlDdP8zU9GtT5nFxrA/8DETy2n4mpYD20WEHZwYGNYabFiM4FM0ci7Yv/jX2JfupbZCF3YuqbvG4t0W8jIy0R8NyO1k+H2iXvMraIBCUUu4/DlPCeE7K1kIiDBHpAyDN3H/lgMdvmkjOps3PEDVvUKZRuKCo2h5oaXjLPwg3yAMEADciABA01cGjqwA4NozCTdb8De+aARAE9hSDnyjCU+HP/GFLapCEIBCUUu4/DlPCeE7K1kIiDBHpAwUANyIAEJlqzUJDe8rx/dBpq+XLIi0BEOB0o4tlWPgemAzT0ApMiCYgEJRS7j8OU8J4TsrWQiIMEekDBgA3IgAQnY/QLEH1uG8P42y/pOZD2AEQJKqTqHjHs1sES+c+EoRp7yAQlFLuPw5TwnhOytZCIgwR6QMHALgSAIEE7l0SeQqBM1nfFQqMbwJO2hoT/G7j+DNIGzONICBg+8Q173y6y+oHAptMxUz0Tl+ODWncrDUrTnaa0gcCn9WFhwBDTwvfbTXdO0aMVSLgxpu5UDN7LissKk9Jyg6eNHBIrw+o95rqkkKXYjlQZOfWaCgswwpoYhh5O3AnmZsebbQhEOx1fm6+0BQlSijmWhAHlJ4DIM3cf+WAx2+aSM6mzc8QNW9QplG4oKjaHmhpeMs/CDfIBAgAMQEQBPYUg58owlPhz/xhS2qQhAUBBF8XpMQCBHHvhUQEBAAAAJbgBF9RrIDhBF9RrkIECQAxARDgdKOLZVj4HpgM09AKTIgmBQEEXxekxAIEce+FRAQEAAAAluAEX1GsgOEEX1GuQgQKADEBECSqk6h4x7NbBEvnPhKEae8FAQRfF6TEAgRx74VEBAQAAACW4ARfUayA4QRfUa5C/wsANEMQ7HV+br7QFCVKKOZaEAeUngAgSHd90WGXWux6C03GrdIBdqSwlD/U034eEO9hwMNaOgo="}],"certificateChain":["MIIBwTCCAWegAwIBAgIEEciBXDAKBggqgRzPVQGDdTA0MQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTEWMBQGA1UEAwwNRFJNIFNlcnZlciBDQTAeFw0xOTA1MDUwNzAwMDBaFw0yNDA1MDYwNjU5NTlaMEUxCzAJBgNVBAYMAkNOMRQwEgYDVQQKDAtTdW1hIFZpc2lvbjEgMB4GA1UEAwwXQ0RSTS1QT0MtRFJNU0VSVkVSLVNVTUEwWTATBgcqhkjOPQIBBggqgRzPVQGCLQNCAARazBO7QgpeM81WW2smbaAPiM0Ag6UhpL41IMaHgkMyH/L4spTaJtuCC7U9wIbcztH0ABCd4iPgXAXepW/cuVDTo1YwVDAOBgNVHQ8BAf8EBAMCB4AwFQYDVR0lAQH/BAswCQYHKoEchu8wBzArBgNVHSMEJDAigCCoXjDqV093IYgV+10OcAxe/hMvkFAT2JbGzeCG1j8ONzAKBggqgRzPVQGDdQNIADBFAiEAkuZ0QIgSY5vpuUVNB4ivlXQOnbTv+FmrBnbunhq/8awCIDSSetEBslOtsqXEsWzCr89+GI8Q1KsgH7vShrQ83GeK","MIIB1TCCAXqgAwIBAgIEPpdMHjAKBggqgRzPVQGDdTAuMQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTEQMA4GA1UEAwwHUm9vdCBDQTAgFw0xOTA1MDUwNzAwMDBaGA8yMDY5MDUwNjA2NTk1OVowNDELMAkGA1UEBgwCQ04xDTALBgNVBAoMBENEVEExFjAUBgNVBAMMDURSTSBTZXJ2ZXIgQ0EwWTATBgcqhkjOPQIBBggqgRzPVQGCLQNCAATBrbIBDT0ZVzSujLTaN+M/6kNFJnBHf+ON4h4Td3ecuqDs3OsX8lzCe2ps3Q9GgkOlTdQvDn0EDc05/Nr93X9Io34wfDApBgNVHQ4EIgQgqF4w6ldPdyGIFftdDnAMXv4TL5BQE9iWxs3ghtY/DjcwDgYDVR0PAQH/BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwKwYDVR0jBCQwIoAg/gShDd110f1FY3fkB+CnCG3gVNkdP8YZv8jbk5SCNNEwCgYIKoEcz1UBg3UDSQAwRgIhAMryOGAga/re2g90+UM9y/tyP4u/TmjP2i1M0BW5vrxiAiEAo/3pXEtWM1z1VbdeV39uGZDmdNSSmLiKhLvz1MvS0hE="]}'
   * 	--local str_req = test ;-- cjson.encode(res) ;
   * 	local str_req = cjson.encode(res) 
   * 	str_req = igsub(str_req, "%\\%/", "%/");
   * 	
   * 	
   * 	local n_str = isub(str_req,1,ilen(str_req)-1);
   * 	local ocsp_res   = "";--_M.ocsp_get();
   * 	local ocsp_state = false;
   * 	
   * 	if node.extensions ~= nil then
   * 		 local infos = node.extensions.drmServerInfos;
   * 		 if infos ~= nil then
   * 			 for i, v in ipairs (infos) do
   * 			 		if v.drmServerID == _M.g_server_id then
   * 			 			ocsp_state = v.ocspState;
   * 			 		end
   * 			 end
   * 		 end
   * 	end	
   * 	if ocsp_state ~= true then ---从模块获取
   * 		-- ocsp_res = [[MIIDFgoBAKCCAw8wggMLBgkrBgEFBQcwAQEEggL8MIIC+DCBq6ADAgEBoiIEIPOW4/jInQt4Q+2u65kHUaSYV4L6SKPxINc9L32dZ2reGA8yMDIwMTAyNzA0MDcwOVowbzBtMFgwDAYIKoEcgUUBgxEFAAQgUqzdC4slHDMq8HdGMx15TlACo9AfDBI9RPUoLj4J0LoEIJMCaI45TBaMbNJbr6/w3oSt++P8z4zPavaWacoyHPr2AgQRyIFcggAYDzIwMjAxMDI3MDQwNzA5WjAMBggqgRzPVQGDdQUAA0gAMEUCIQCHxZr7dy1bTtidpMMnFmpxEFUzhCqnzN2RvY1pHiWlvAIgA63JB+/9c2VQqL3ouARvfhIsCmwmJsCz8e6Qb7130LagggHuMIIB6jCCAeYwggGMoAMCAQICBGmnNx0wCgYIKoEcz1UBg3UwNDELMAkGA1UEBgwCQ04xDTALBgNVBAoMBENEVEExFjAUBgNVBAMMDURSTSBTZXJ2ZXIgQ0EwHhcNMjAwNzMwMTYwMDAwWhcNMjAxMDMxMTU1OTU5WjArMQswCQYDVQQGDAJDTjENMAsGA1UECgwEQ0RUQTENMAsGA1UEAwwET0NTUDBZMBMGByqGSM49AgEGCCqBHM9VAYItA0IABAT+e7tx1LOAgazwZQM/QFBGYaZszs9SptwKIzNSWAz2kP/jQSU1Lmtk1B127OZjjLLYtlQuwe7vFpGT4l2FstijgZQwgZEwKQYDVR0OBCIEIPOW4/jInQt4Q+2u65kHUaSYV4L6SKPxINc9L32dZ2reMA4GA1UdDwEB/wQEAwIHgDAWBgNVHSUBAf8EDDAKBggrBgEFBQcDCTAPBgkrBgEFBQcwAQUEAgUAMCsGA1UdIwQkMCKAIHCVPRGoDbM8NYQPuriI/jMfnNhPxuXq3m4KYkynOwZYMAoGCCqBHM9VAYN1A0gAMEUCIQDXMsPzOlFUnxFrfwVgU23RcG9vx7Xge8zW2fZ00nEBlQIgXVs8pSr6vRUf2GhOG2dai58qAHXRaFJnYpdUUPXzcHE=]];
   * 		-- sign     = gconcat ({n_str , ",\"ocspResponse\":\"" , ocsp_res , "\",\"signature\":\"\"}"});
   * 		--resp_str = gconcat ({n_str , ",\"ocspResponse\":\"" , ocsp_res , "\",\"signature\":\"" , csignature (sign) , "\"}"});
   * 		sign     = gconcat ({n_str , ",\"signature\":\"\"}"});
   * 		resp_str = gconcat ({n_str , ",\"signature\":\"" , csignature (sign) , "\"}"});
   * 	else
   * 		sign     = gconcat ({n_str , ",\"signature\":\"\"}"});
   * 		resp_str = gconcat ({n_str , ",\"signature\":\"" , csignature (sign) , "\"}"});
   * 	end
   * 	ngx.log(ngx.ERR, "resp3=" .. resp_str);
   * 	ngx.print(resp_str);
   * 	ngx.exit(200);
   * end */
  lua_pushvalue(L,(lc120 + lc_nextra));
  lua_pushcclosure(L,lcf1__M_handle,1);
  lc_getupvalue(L,(lc120 + lc_nextra),10,7);
  lua_insert(L,-2);
  lua_pushliteral(L,"handle");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 24);
  
  /* return _M */
  lc_getupvalue(L,(lc120 + lc_nextra),10,7);
  return 1;
  assert(lua_gettop(L) - lc_nextra == 24);
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


static int lc_pmain(lua_State * L) {
  luaL_openlibs(L);

  const lc_args_t * const args = (lc_args_t*)lua_touserdata(L, 1);
  lc_createarg(L, args);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);
  int i;
  for (i=1; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
  }
  int status2 = lua_pcall(L, args->c-1, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


int main(int argc, const char ** argv) {
  lc_args_t args = {argc, argv};
  lua_State * L = luaL_newstate();
  if (! L) { fputs("Failed creating Lua state.", stderr); exit(1); }

  int status = lua_cpcall(L, lc_pmain, &args);
  if (status != 0) {
    fputs(lua_tostring(L,-1), stderr);
  }

  lua_close(L);
  return 0;
}


