/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


#include <assert.h>

/* __div metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_div(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) / lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__div")||luaL_getmetafield(L,idxb,"__div")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: bisect
 * function(f,a,b,fa,fb) */
static int lcf1_bisect (lua_State * L) {
  enum { lc_nformalargs = 5 };
  lua_settop(L,5);
  
  /* local c=(a+b)/2 */
  lc_add(L,2,3);
  lua_pushnumber(L,2);
  lc_div(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 6);
  
  /* io.write(n," c=",c," a=",a," b=",b,"\n") */
  lua_getfield(L,LUA_ENVIRONINDEX,"io");
  lua_pushliteral(L,"write");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_getfield(L,LUA_ENVIRONINDEX,"n");
  lua_pushliteral(L," c=");
  lua_pushvalue(L,6);
  lua_pushliteral(L," a=");
  lua_pushvalue(L,2);
  lua_pushliteral(L," b=");
  lua_pushvalue(L,3);
  lua_pushliteral(L,"\n");
  lua_call(L,8,0);
  assert(lua_gettop(L) == 6);
  
  /* if c==a or c==b or math.abs(a-b)<delta then */
  enum { lc1 = 6 };
  lua_pushvalue(L,6);
  lua_pushvalue(L,2);
  const int lc2 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushvalue(L,6);
    lua_pushvalue(L,3);
    const int lc3 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc3);
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"math");
    lua_pushliteral(L,"abs");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lc_sub(L,2,3);
    lua_call(L,1,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"delta");
    const int lc4 = lua_lessthan(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc4);
  }
  const int lc5 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc5) {
    
    /* return c,b-a */
    lua_pushvalue(L,6);
    lc_sub(L,3,2);
    return 2;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc1);
  assert(lua_gettop(L) == 6);
  
  /* n=n+1 */
  lua_getfield(L,LUA_ENVIRONINDEX,"n");
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_setfield(L,LUA_ENVIRONINDEX,"n");
  assert(lua_gettop(L) == 6);
  
  /* local fc=f(c) */
  lua_pushvalue(L,1);
  lua_pushvalue(L,6);
  lua_call(L,1,1);
  assert(lua_gettop(L) == 7);
  
  /* if fa*fc<0 then */
  enum { lc6 = 7 };
  lc_mul(L,4,7);
  lua_pushnumber(L,0);
  const int lc7 = lua_lessthan(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc7);
  const int lc8 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc8) {
    
    /* return bisect(f,a,c,fa,fc) */
    const int lc9 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"bisect");
    lua_pushvalue(L,1);
    lua_pushvalue(L,2);
    lua_pushvalue(L,6);
    lua_pushvalue(L,4);
    lua_pushvalue(L,7);
    lua_call(L,5,LUA_MULTRET);
    return (lua_gettop(L) - lc9);
    assert(lua_gettop(L) == 7);
  }
  else {
    
    /* else
     * return bisect(f,c,b,fc,fb) */
    const int lc10 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"bisect");
    lua_pushvalue(L,1);
    lua_pushvalue(L,6);
    lua_pushvalue(L,3);
    lua_pushvalue(L,7);
    lua_pushvalue(L,5);
    lua_call(L,5,LUA_MULTRET);
    return (lua_gettop(L) - lc10);
    assert(lua_gettop(L) == 7);
  }
  lua_settop(L,lc6);
  assert(lua_gettop(L) == 7);
  return 0;
}


/* name: solve
 * function(f,a,b) */
static int lcf1_solve (lua_State * L) {
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* n=0 */
  lua_pushnumber(L,0);
  lua_setfield(L,LUA_ENVIRONINDEX,"n");
  assert(lua_gettop(L) == 3);
  
  /* local z,e=bisect(f,a,b,f(a),f(b)) */
  lua_getfield(L,LUA_ENVIRONINDEX,"bisect");
  const int lc11 = lua_gettop(L);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_pushvalue(L,3);
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  lua_pushvalue(L,1);
  lua_pushvalue(L,3);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc11),2);
  assert(lua_gettop(L) == 5);
  
  /* io.write(string.format("after %d steps, root is %.17g with error %.1e, f=%.1e\n",n,z,e,f(z))) */
  lua_getfield(L,LUA_ENVIRONINDEX,"io");
  lua_pushliteral(L,"write");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc12 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"string");
  lua_pushliteral(L,"format");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  const int lc13 = lua_gettop(L);
  lua_pushliteral(L,"after %d steps, root is %.17g with error %.1e, f=%.1e\n");
  lua_getfield(L,LUA_ENVIRONINDEX,"n");
  lua_pushvalue(L,4);
  lua_pushvalue(L,5);
  lua_pushvalue(L,1);
  lua_pushvalue(L,4);
  lua_call(L,1,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc13),LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc12),0);
  assert(lua_gettop(L) == 5);
  return 0;
}


/* name: f
 * function(x) */
static int lcf1_f (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* return x*x*x-x-1 */
  lc_mul(L,1,1);
  lc_mul(L,-1,1);
  lua_remove(L,-2);
  lc_sub(L,-1,1);
  lua_remove(L,-2);
  lua_pushnumber(L,1);
  lc_sub(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  return 1;
  assert(lua_gettop(L) == 1);
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  #ifndef NDEBUG
  const int lc_nactualargs = lua_gettop(L);
  #endif
  #ifndef NDEBUG
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  #endif
  
  /* -- bisection method for solving non-linear equations
   * delta=1e-6 */
  lua_pushnumber(L,1e-06);
  lua_setfield(L,LUA_ENVIRONINDEX,"delta");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- tolerance
   * function bisect(f,a,b,fa,fb)
   *  local c=(a+b)/2
   *  io.write(n," c=",c," a=",a," b=",b,"\n")
   *  if c==a or c==b or math.abs(a-b)<delta then return c,b-a end
   *  n=n+1
   *  local fc=f(c)
   *  if fa*fc<0 then return bisect(f,a,c,fa,fc) else return bisect(f,c,b,fc,fb) end
   * end */
  lua_pushcfunction(L,lcf1_bisect);
  lua_setfield(L,LUA_ENVIRONINDEX,"bisect");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- find root of f in the inverval [a,b]. needs f(a)*f(b)<0
   * function solve(f,a,b)
   *  n=0
   *  local z,e=bisect(f,a,b,f(a),f(b))
   *  io.write(string.format("after %d steps, root is %.17g with error %.1e, f=%.1e\n",n,z,e,f(z)))
   * end */
  lua_pushcfunction(L,lcf1_solve);
  lua_setfield(L,LUA_ENVIRONINDEX,"solve");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- our function
   * function f(x)
   *  return x*x*x-x-1
   * end */
  lua_pushcfunction(L,lcf1_f);
  lua_setfield(L,LUA_ENVIRONINDEX,"f");
  assert(lua_gettop(L) - lc_nextra == 0);
  
  /* -- find zero in [1,2]
   * solve(f,1,2) */
  lua_getfield(L,LUA_ENVIRONINDEX,"solve");
  lua_getfield(L,LUA_ENVIRONINDEX,"f");
  lua_pushnumber(L,1);
  lua_pushnumber(L,2);
  lua_call(L,3,0);
  assert(lua_gettop(L) - lc_nextra == 0);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


static int lc_pmain(lua_State * L) {
  luaL_openlibs(L);

  const lc_args_t * const args = (lc_args_t*)lua_touserdata(L, 1);
  lc_createarg(L, args);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);
  int i;
  for (i=1; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
  }
  int status2 = lua_pcall(L, args->c-1, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


int main(int argc, const char ** argv) {
  lc_args_t args = {argc, argv};
  lua_State * L = luaL_newstate();
  if (! L) { fputs("Failed creating Lua state.", stderr); exit(1); }

  int status = lua_cpcall(L, lc_pmain, &args);
  if (status != 0) {
    fputs(lua_tostring(L,-1), stderr);
  }

  lua_close(L);
  return 0;
}


