// VERSION 0.0.1

function Buffer(arraybuffer, offset, length) {
  var data;
  if (arguments.length === 1) {
    if (Array.isArray(arraybuffer)) {
      data = arraybuffer;
      arraybuffer = new ArrayBuffer(data.length);
      var v = new Uint8Array(arraybuffer);
      for (var i = 0, l = data.length; i < l; i++) {
        v[i] = data[i];
      }
    }
    else if (typeof arraybuffer === "number") {
      arraybuffer = new ArrayBuffer(arraybuffer);
    }
    offset = 0;
    length = arraybuffer.byteLength;
  }
  var buffer = new Uint8Array(arraybuffer, offset, length);
  buffer.__proto__ = Buffer.prototype;
  buffer.view = new DataView(arraybuffer, offset, length);
  buffer.offset = offset;
  buffer.length = length;
  return buffer;
}
Buffer.prototype.__proto__ = Uint8Array.prototype;
Buffer.prototype.slice = function (start, end) {
  return Buffer(this.buffer, start + this.offset, end - start);
};
Buffer.prototype.readUInt32LE = function (offset) {
  return this.view.getUint32(offset, true);
};
Buffer.prototype.readUInt16LE = function (offset) {
  return this.view.getUint16(offset, true);
};
Buffer.prototype.readInt16LE = function (offset) {
  return this.view.getInt16(offset, true);
};
Buffer.prototype.readDoubleLE = function (offset) {
  return this.view.getFloat64(offset, true);
};
Buffer.prototype.writeDoubleLE = function (value, offset) {
  return this.view.setFloat64(offset, value, true);
};
Buffer.prototype.writeUInt32LE = function (value, offset) {
  this.view.setUint32(offset, value, true);
};
Buffer.prototype.toString = function (encoding) {
  if (!encoding) {
    return String.fromCharCode.apply(null, this);
  }
};// [
// type , 类型    4 字节
// len,   长度    4 字节 
// pc	  addr    4字节  
// size   n       4 字节
// ]
//////
function compile_cstring_v2p (string) {
	///创建一个str ptr
	//comile_new_ptr("KSTR", string, string.length);
	
}



///设置完 eax
/***
* 构建一个指针
*/
function comile_new_ptr (type, len) {
	//16
	//pc
	var ctype = 0; // null
	switch (type) {
		case "KNUM":
		case "KSHORT":
			ctype =1;
		break;
		case "KSTR":
			ctype =2;
		break;
		case "KOBJECT":
			ctype =3;
		break;
		case "KARRAY":
			ctype =4;
		break;
	}
	var codes = [];
	codes[0] = `
	;; ptr is alloc 
	get_global 0 ;; ptr
	;;set_local  0 ;; push
	i32.const ${ctype}
	i32.store
	`
	/////尺寸
	var size_t = len ? len : 100;
	// var ele_t  = 0;
	
	switch (type) {
		case "KNUM":
		case "KSHORT":
			size_t = 0;
		break;
		case "KSTR":
			size_t =len;
		break;
		case "KOBJECT":
			size_t =len;
		break;
		case "KARRAY":
			size_t =len;
		break;
	}
	codes[1] = `
	i32.const 4 
	get_global 0
	i32.add ;;  obj size 
	i32.const ${size_t}
	i32.store
	`
	//写入元素个数
	codes[2] = `
	i32.const 8 
	get_global 0
	i32.add ;;  obj eles 
	i32.const 0
	i32.store
	`
	//写入内存地址
	//global or block
	//默认为null 没有初始化
	codes[3] = `
	i32.const 12
	get_global 0
	i32.add ;;  value addr 
	i32.const 0
	i32.store
	`
	
	codes [4] = `
	i32.const 16
	get_global 0
	set_global 0 ;; incr pc
	`
	
	return codes.join("\n")
}/***
* 常量节区
* 该节区数据不可更改，不会释放
*/

var const_section = {}
const_section.const_ip = 0;
const_section.bytes = new Uint8Array(0);//64M
const_section.symblos= [0];

const_section.print = function () {
	console.log(const_section.bytes.subarray(0,100));
	console.log(const_section.symblos);
}

const_section.set = function (bytes, info) {
	info.sip = const_section.symblos.length;
	const_section.symblos.push([const_section.const_ip, bytes.length]);
	const_section.bytes.set(bytes, const_section.const_ip);
	const_section.const_ip += bytes.length;
	const_section.print();
}

const_section.jit = [];

const_section.init = function () {
	var len = const_section.symblos.length;
	const_section.jit = new  Array(len);
	
	for(var i=1;i < len; i++){
		var p = const_section.symblos[i];
		var b = const_section.bytes.subarray(
			p[0],
			p[0] + p[1]
		);
		
		const_section.jit[i] = decoder.decode(b);
	}
	
	console.log(const_section.jit);
}

const_section.get = function (sip) {
	return const_section.jit[sip];
}







function debug(_block , word) {
	//_block.data.push(";;;" + word);
}

    
function Block () {
this.data     = [];
this.func     = null;
this.fname    = "";
this.index    = -1;
this.regnum   = "";//寄存器
this.symblos  = [];
this.isfloat  = 0;
this.alloc_pc = 0;
this.tags_start  = {};
this.tags_end    = [];
this.static_data = [];
this.static_pc   = 8092; ///8KB 每页
}
	    
	///函数模板
	var func_tml = `
;;;;func
(func $\m{*data.index*}
{%if (data.fname) do %}(export {{fname}}){%end%}
{%ipairs i,v in data.numparams do %}(param f64){%end%}
(result f64) 
{{regnum}}
{{data}}
)`;var stack  = [];
var blocks = [];
var funcIndex_G = 0;
var alloc_pc = 0;


function find_block_index_by_name  (name) {
	console.log(name, ">>>");
	var len = blocks.length;
	var search = "\"" + name + "\"";
	for(var i = 0; i< len; i++) {
		console.log(blocks[i].fname);
		if(blocks[i].fname == search) {
			return i;
		}
	}
	return -1;
}


function find_block_by_idx (idx) {
	var len = blocks.length;
	for(var i = 0; i< len; i++) {
		if(blocks[i].index == idx) {
			return blocks[i];
		}
	}
	
	return null;
}

var gloabl_module = {
	static_pc:8092
}
//var encoder = new TextEncoder('utf8');
//var decoder = new TextDecoder();
var static_data = [];

///静态字符串
function inline_build_in_cstr(arr, n, _block) {
  n = n + "";
  var len = n.length;
  var buff = [n];
  $ebx[$ecx].idx = _block.symblos.length;
  var str = '(data (i32.const '+ gloabl_module.static_pc + ') "'+buff.join("")+'")';
  _block.symblos.push({ pc: gloabl_module.static_pc, type: 'KSTR' , size:len});
  static_data.push(str);
  arr.push(";; i32.const " +  gloabl_module.static_pc + ";; char * " + n);
  return  gloabl_module.static_pc  += len;
}

//  复合类型
//  [type, size, len, ptr]
//  i32 i32 i32 i32 
//  指针放入栈，数据方式堆
var HEAP_SIZE_BLOCK=100;
function inline_build_in_object(arr, _block) {
  ///申请一块数据存放该指针指向的数据
  $ebx[$ecx].idx = _block.symblos.length;
  
  //写入类型
  arr.push("i32.const " +  _block.alloc_pc);
  arr.push("i32.const 1 ;; type object");
  arr.push("i32.store");
  
  //写入尺寸 默认分配100*4 = 400B
  arr.push("i32.const " +  (_block.alloc_pc + 4));
  arr.push("i32.const " +   HEAP_SIZE_BLOCK);
  arr.push("i32.store");
  
  //写入元素个数 
  arr.push("i32.const " +  (_block.alloc_pc + 8));
  arr.push("i32.const 0 ;; ele length");
  arr.push("i32.store");
  
  //写入数据的地址
  arr.push("i32.const " +  (_block.alloc_pc + 12));
  //动态分配内存块
  var msize = 4 /*i32*/ * HEAP_SIZE_BLOCK ;//size of alloc
  
  arr.push("i32.const "+gloabl_module.static_pc+";;  ele ptr");
  arr.push("i32.store");
  gloabl_module.static_pc += msize;
  _block.symblos.push({ pc: _block.alloc_pc , type: 'KOBJECT' });
  return  _block.alloc_pc += 16;
}
/***
*返回增长的内存索引
*/
function inline_build_in_number(arr, n, _block) {
  arr.push("i32.const " + _block.alloc_pc);
  if((n+"").indexOf(".") == -1) {
	 n = n + ".0";
  }
  arr.push("f64.const " + n);
  arr.push("f64.store");
  return _block.alloc_pc+=8;
}

function pre_gen_function (codes) {
	////快速预处理不可预测分支的内容
	var len = codes.length;
	for(var i = 0; i< len; i++){
		var block = codes[i];
		
		if(block.bcins) {
			var eax = block.bcins;
			var ebx = eax.length;
			
			for(var k = 0; k < ebx; k ++) {
				//console.log(eax[k]);
				if(eax[k].op == "FNEW"){
					console.log("fnew");
					var precodes = eax[k].args[1].bcins;
					gen_block_code(precodes, -1, false, 2);
				}
			}
		}
	}
	console.log(global);
	//gen_block_code(codes, -1, false, 2);
}
function gen_block_code (codes, cindex, main , numparams) {
		 
		  
			var _block = new Block();
		  _block.numparams = [];
		  _block.index = cindex ;
		  _block.symblos   = [];
		  _block.data.push(";;param");
			
		  for(var i = 0; i< numparams; i++) {
			_block.numparams[i] = 1;///参数索引
			_block.data.push("i32.const " + _block.alloc_pc);
			_block.data.push("get_local "+ i);
			_block.data.push("f64.store");
			_block.alloc_pc+=8
			_block.symblos.push({pc:_block.alloc_pc, type:"KNUM"});		
		  }
		 
		  funcIndex_G  = 0;
		  var index = 0;
		  $ebx  = codes;
		  var len  = codes.length;
		  for(var i = 0; i< len; i++) {
			var code = codes[i];
			$ecx = i;
			
			_block.data.push(";; " + code.op);
			
			switch (code.op){
				case "TSETV":
				op_tsetv(code, _block);
				break;
				case "TGETB":
				case "TGETS":
					op_tget(code, _block)
					break;
				case "TSETB":
				case "TSETS":
					op_tset(code, _block)
				break;
				case "IST":
				case "ISF":
					op_istf( code, _block);
				break;
				case "ISNEV":
				case "ISEQV":
					op_isnev(code, _block);
				break;
				case "FORI":
				case "FORL":
					op_fori(code, _block);
				break;
				case "ADDVN" :
				case "ADDVV" :
				case "ADDNV" :
					op_add(code, _block);
				break;
				case "MULVV":
				case "MULVN":
				case "MULNV":
					op_mul(code, _block);
				break;
				case "SUBVV"://sub
				case "SUBVN":
				case "SUBNV":
					op_sub(code, _block);
				break;
				case "DIVVV":
				case "DIVVN":
				case "DIVNV":
					op_dev(code, _block);
				break;
				case "JMP":
					op_jump(code, _block);
				break;
				case "ISGE":
				case "ISEQN":
				case "ISNEN":
				case "ISGT":
					op_condi(code, _block);
				break;
				case "TNEW":
					require_hash();
					var pc = inline_build_in_object(_block.data , _block);
				break;
				case "KSHORT":
					var pc = inline_build_in_number(_block.data, 
					code.args[1],
					_block);
					codes[i].idx = _block.symblos.length;
					_block.symblos.push({pc:pc, type:"KSHORT"});
				break;
				case "KNUM":
					var pc = inline_build_in_number(_block.data, 
					code.args[1], _block);
					codes[i].idx = _block.symblos.length;
					_block.symblos.push({pc:pc, type:"KNUM"});
				break;
				case "KSTR":
					var pc = inline_build_in_cstr(_block.data, 
					code.args[1], _block);
					//codes[i].idx = _block.symblos.length * -1;
				break;
				case "RET1":
				case "RET":
				case "RET0":
					op_ret(code, _block);
				break;
				case "MODVV":
				case "MODNV":
				case "MODVN":
					op_mod(code, _block);
				break;
				case "KPRI":
					op_kpri(code, _block);
				break;
				case "MOV":
					op_mov (code, _block);
				break;
				case "FNEW":
					var inline = code.args[1];
					var id     = code.args[1].index;
					stack.push(id);
					
				
					//console.log(id, blocks);
					//console.log("inline=:>" , inline);
				break;
				case "GSET":
					op_gset(code, _block);
				break;
				case "GGET":
					op_gget(code, _block);
				break;
				case "CALL":
				case "CALLT":
				case "CALLM":
					op_call(code, _block);
				break;
				case "CAT":
					op_cat(code, _block);
				break;
				default:
					_block.data.push(";;; not implements " + code.op);
				break;
			}
			index_tag(i, _block); ///tag
			
		  }
		  
		  var f = template.compile( func_tml );
		  _block.func = f;
		  if(main) {
			  _block.fname = "\"main\"";
		  }
		  _block.data = _block.data.join("\n");
		  _block.regnum = "(local i32 i32 i32 i32 i32 i32 i32 i32 i32 i32)";
		
		  console.log(codes);
		  console.log(_block.symblos);
		  blocks[_block.index] = _block;
	  }
	 
	  function compile (v) {
		var len = v.length;
		pre_gen_function(v);
		
		for(var i = 0; i< len; i++){
			var block = v[i];
//				console.log(block);
			if(block.bcins) {
				///生成函数
				if(block.flags == 3 || len ==1) {
					gen_block_code(block.bcins, block.index, true, block.numparams);
				} else {
					gen_block_code(block.bcins, block.index, false,block.numparams );
				}
			}
		}
		
		var output=  [];
		for(var i = 0; i< blocks.length; i++){
			var block = blocks[i];
			output.push(block.func (block));
		}
		
		//data
		output.unshift(static_data.join("\n"));
		//调试内存
		output.unshift(inlines_std_mem.join("\n"));
		
		output.unshift('(memory (export "mem") 10)')
		//output.unshift('(global i32 (i32.const 1) ;; eax')
			
		output.unshift('(global (mut i32) (i32.const 0)) ;; eax')
		output.unshift('(global (mut i32) (i32.const 0)) ;; ebx')
		output.unshift('(global (mut i32) (i32.const 0)) ;; ecx')
		output.unshift('(global (mut i32) (i32.const 0)) ;; edx')
		output.unshift('(global (mut i32) (i32.const 0)) ;; pc')
		//output.unshift('(global (mut i32) (i32.const 0)) ;; edx')
		
		output.unshift('(import "console" "log"  (func $print (param f64)))')
		output.unshift('(import "console" "log"  (func $print_i  (param i32)))')
		output.unshift('(import "console" "log2" (func $print_s (param i32)(param i32) ))')
		
		var code = (output.join("\n"))
		
		if(code.indexOf("not implements") != -1) {
			console.log(code);
			console.log("error::failed to compile. ");
			return "(module)"
		}
		
		return code;
		
	  }


function op_add (code, _block) {
	console.log(_block.symblos);
	try {
	var src =  _block.symblos[code.args[2]];
	var dst =  _block.symblos[code.args[1]];
	$ebx[$ecx].idx = code.args[0]; 
///eax
	if(!_block.symblos[code.args[0]]) {
		var pc = inline_build_in_number(_block.data, 0 , _block);
	    _block.symblos[code.args[0]]  = {pc:pc, type:"KNUM"};
		pc = pc - 8;
	} else {
		var pc = _block.symblos[code.args[0]].pc - 8; 
		if  (!pc) {
			pc  = 0;
		}
		
		if(pc < 0) {
			pc = 0;
		}
	}
	_block.data.push("i32.const " + pc + ";;;idx");
	
	if("ADDVN" == code.op || "ADDNV" == code.op) {
		var src = code.args[2] + "";
		if(src.indexOf(".") == -1) {
			src = src + ".0";
		}
		_block.data.push("f64.const " + src + ";;; const");
	} 
	else {	
		if(src) {
			get_value_from_symblos(src, _block);
		} else {
			_block.data.push(";; run this 1");
			console.log(_block.symblos);
		}
	}
	
	if(dst) {
		get_value_from_symblos(dst, _block);
		
	} else {
		_block.data.push(";; run this 2");
		console.log(_block.symblos);
	}
	
	_block.data.push("f64.add " );
	_block.data.push("f64.store " );
	}catch(e) {
	}
}

function op_call(code, _block) {

  var params_base = code.args[2];
  var len         = code.args[1];
  
  console.log($ebx);
  var is_tget = ($ebx[$ecx-1].op== "TGETB");
  
  if(is_tget) {
		look_at_reg_for_table(_block);
  } else {
		if(code.op == "CALLM") {
			look_at_make_callm_params(params_base, _block);
		} else {
			look_at_make_callm_params(params_base, _block);
		}
  }

  
  //look_at_make_callm_params2(code, _block);
  var fname = look_at_function_name(code.args[0], _block);
  
  if(!fname) {
	   _block.data.push("stack error ");
  }
  
  if(fname.charAt(0) != "$") {
	fname = "$"+fname;
  }
  
  //console.log(fname);
  _block.data.push("call " + fname);
}

function op_cat (code, _block) {
	try {
		var dst = code.args[0];
		var from= code.args[1];
		var to  = code.args[2];
		var idx = [];
		for(var i = from; i <= to ; i++) {
			console.log("===", $ebx[i]);
			idx.push($ebx[i].idx);
		}
		require_copy_to_string(); //导入std库
		///set eax 0 to save ptr
		_block.data.push("i32.const "+_block.alloc_pc+";; new string"); 
		
		_block.data.push("set_local 0"); /// eax is addr
		_block.data.push("get_local 0"); /// eax is addr
		_block.data.push("set_local 1"); /// eax is addr
			
		var size_t = 0;
		for(var i = 0; i < idx.length ; i++) {
			var ele = _block.symblos[idx[i]];
			size_t += ele.size;
			_block.data.push("get_local 1");
			_block.data.push("i32.const " + ele.pc);
			_block.data.push("i32.const " + ele.size);
			_block.data.push("call $copy_to_string");
			_block.data.push("set_local 1");
		}
		$ebx[$ecx].idx = _block.symblos.length ;
		_block.symblos[$ebx[$ecx].idx] = {pc:_block.alloc_pc,
									   type:"KSTR",
									   size:size_t};

		_block.alloc_pc += size_t;
		_block.data.push("i32.const " + size_t); //-->addr, 1 -> len
		_block.data.push("set_local 1"); 
		
		
	} catch(e) {
		
	}
}
function op_condi (code, _block) {
	var src =  _block.symblos[code.args[0]];
	var dst =  _block.symblos[code.args[1]];
	$ebx[$ecx].cond = 1;
	if(src) {
		var dd = find_nearest_stack_ele($ecx, code.args[0]);
		if(dd) {
			get_value_from_symblos(_block.symblos[dd.idx], _block);
		} else {
			get_value_from_symblos(src, _block);
		}
	} else {
		console.log(_block.symblos);
	}
	

	
	if("ISNEN" == code.op) {
		_block.data.push("f64.const " + code.args[1] + ".0");
	} else {
		if(dst) {
			var dt = find_nearest_stack_ele($ecx, code.args[1]);
			if(dt) {
				get_value_from_symblos(_block.symblos[dt.idx], _block);
			} else {
				get_value_from_symblos(dst, _block);
			}
		} else {
			console.log(_block.symblos);
		}
	}
	switch(code.op) {
		case  "ISEQN":
		_block.data.push("f64.eq");
		break;
		case  "ISGT":
			if(code.args[2] == "le") {
				_block.data.push("f64.le");
			} else {
				_block.data.push("f64.ge");
			}
		break;
		case  "ISGE":
			if(code.args[2] == "lt") {
				_block.data.push("f64.lt");
			} else {
				_block.data.push("f64.ge");
			}
		break;
		case "ISNEN":
			if(code.args[2] == "eq") {
				_block.data.push("f64.eq");
			} else {
				_block.data.push("f64.ne");
			}
		break;
	}
	
}



function op_dev (code, _block) {
	//console.log(_block.symblos);
	
	try {
	var src =  _block.symblos[code.args[1]];
	var dst =  _block.symblos[code.args[2]];
	$ebx[$ecx].idx = code.args[0];
	if(!_block.symblos[code.args[0]]) {
		var pc = inline_build_in_number(_block.data, 0 , _block);
	    _block.symblos[code.args[0]]  = {pc:pc, type:"KNUM"};
		pc = pc - 8;
	} else {
		var pc = _block.symblos[code.args[0]].pc - 8; 
		if  (!pc) {
			pc  = 0;
		}
		
		if(pc < 0) {
			pc = 0;
		}
	}
	_block.data.push("i32.const " + pc + ";;;idx");
	
	if(src) {
		get_value_from_symblos(src, _block);
	}
	
	
	if("DIVVN" == code.op || "DIVNV" == code.op) {
		var src = code.args[2] + "";
		if(src.indexOf(".") == -1) {
			src = src + ".0";
		}
		
		_block.data.push("f64.const " + src + ";;; const");
	} else {	
		if(src) {
			get_value_from_symblos(dst, _block);
		}
	}
	

	
	_block.data.push("f64.div " );
	_block.data.push("f64.store " );
	}catch(e) {
	}
}

function op_fori(code, _block) {

  //var params_base = code.args[2];
  //var len         = code.args[1];
 
  if (code.op == "FORL"){
	///base 
	var eles = find_fori_ele($ecx, code.args[0]);

	if(eles.length == 3) {
		var step  = _block.symblos[eles[2].args[0]];
		var end   = _block.symblos[eles[1].args[0]];
		var start = _block.symblos[eles[0].args[0]];
		
		
			/// i != n
		var pc1 = get_value_from_symblos(start, _block);
		var pc3 = get_value_from_symblos(end , _block);
		_block.data.push("f64.ne");
		_block.data.push("set_local 7");
		
		var idx = _block.symblos[eles[0].args[0]].pc - 8;
		if (idx < 0) {
			idx = 0;
		}
		//i ++
		_block.data.push("i32.const " + idx);
		var pc1 = get_value_from_symblos(start, _block);
		var pc2 = get_value_from_symblos(step , _block);
		_block.data.push("f64.add");
		_block.data.push("f64.store");
		
		
		
	
		_block.data.push("get_local 7");
		_block.data.push("if");
		_block.data.push("br $loop" + $ebx[$ecx].loop);
		_block.data.push("end");
	}

	
	_block.data.push("end ;;end fori");
  } else {
	///i = 0;
	var pc = inline_build_in_number(_block.data, 0 ,_block);
	$ebx[$ecx].idx = _block.symblos.length;
	_block.symblos.push({pc:pc, type:"KNUM"});
    
	
	//======================loop===================
	$ebx[$ecx+ code.args[1]].loop = code.args[1];
	
	_block.data.push("loop $loop" + code.args[1]);
	////mov start to i
	
	_block.data.push("i32.const " + ((pc - 8) < 0? 0:pc-8));
	var eles = find_fori_ele($ecx, code.args[0]);
	if(eles && eles.length > 0) {
		var start = _block.symblos[eles[0].args[0]];
		var pc1 = get_value_from_symblos(start, _block);
	}
	_block.data.push("f64.store");
	
	///mov start to i;
  }
}

/***
*
*/
var vm_func = {
	"print":1,
	"print_t":1,
	"print_s":1,
	"array":1
}

function op_gget (code, _block) {
  ////
  	if(code.args[2] == "index") { 
		var name = code.args[1];
		var ele = get_gloabl_var_by_name(name, _block);
		
		if(ele != null) {
			$ebx[$ecx].vname = ele.vname;
			//console.log(";;;;1", ele, name);
			//get_value_from_symblos(ele ,_block);
		}else if(look_at_hasCall()) { /// isFunction
			////搜索内部函数
		
			var idx  = find_block_index_by_name(name);
			//console.log("idx=", name);
			if( idx != -1 ){
				$ebx[$ecx].fname = "$m" + idx;
			} else {
				////搜索vm级别函数
				
				if(vm_func[name]) {
					$ebx[$ecx].fname = "$" + name;
				} else {
					$ebx[$ecx].fname = "$m" + _block.index;
				}
			}
		}
	}
}




var global = {};

function op_gset(code, _block) {

  var params_base = code.args[2];
  var len         = code.args[1];
  
  if(code.args[2] == "newindex") {
	  
	  if(look_at_is_func($ecx)) {
		var fun_e = stack.pop();
		var mblocks= find_block_by_idx(fun_e)
		
		if(mblocks != null) {
			mblocks.fname = "\"" + code.args[1] +"\""
		}
	  } else if(look_at_is_var($ecx)) {
		///全局变量
		_block.symblos[code.args[0]].vname= code.args[1];
		$ebx[$ecx].vname= code.args[1];
		$ebx[$ecx].idx  = code.args[0];
		
		global[$ebx[$ecx].vname] = _block.symblos[code.args[0]];
	  } else {
	  }
		
	}
}

/**
*  
*/
function op_isnev (code, _block) {
	//// 1 dst 操作数
	//// 0 堆栈数
	var dst = _block.symblos[code.args[1]];
	var src = _block.symblos[code.args[0]];
	$ebx[$ecx].cond = 1;
	require_str_cmp();
	
	if (src) {
		get_value_from_symblos(src, _block);
	}
	
	if (dst) {
		get_value_from_symblos(dst, _block);
	}
	switch (dst.type) {
		case "KSTR":
		if("eq" == code.args[2]) {
			_block.data.push(";;str eq");
			_block.data.push("call $str_cmp");
			//_block.data.push("call $print_i");
			//_block.data.push("i32.const 0");
			if("ISEQV" == code.op) {
				_block.data.push("i32.const 0");
			} else {
				_block.data.push("i32.const 1");
			}
			
			_block.data.push("i32.eq");
		}
		break;
	}
	
	console.log("===========",_block.symblos[dst]);
}
function op_istf (code, _block) {
	$ebx[$ecx].cond = 1;
	
	var src = _block.symblos[code.args[0]];
	
	if (src) {
		get_value_from_symblos(src, _block, true);
	}
	
	if(code.op == "IST"){
		_block.data.push("f64.const 0.0");
	} else {
		_block.data.push("f64.const 1.0");
	}
	
	_block.data.push("f64.eq");
}


var hasElse = false;
//var jmp_stack =  [];
function is_else (line) {
	var pre = line - 1;
	
	if(!$ebx[pre].cond) {
		return true;
	}
	
	return false;
}

function insert_nop_eof (idx, _block) {
	//var code = { op: 'EOF', args: [ 1, 9 ] },
	_block.tags_end .push({num : idx,tag : $ecx});
}

function is_else_if(idx) {
	var pre = $ebx[idx-1];
	
	if(!pre.cond) {
		return false;
	}
	
	var next = $ebx[idx+1];
	
	if(!next.cond) {
		return false;
	}
	var next2 = $ebx[idx+2];
	
	if(next2.op != "JMP" ) {
		return false;
	}
	
	return true;
}

function op_jump (code, _block) {
	//console.log(_block.symblos);
	try {
		var e = $ecx + code.args[1] ;
	
		if(is_else($ecx)){
			_block.data.push("else ;; @" + $ecx);
			insert_nop_eof(e, _block);
			//console.log(_block.tags_end );
			
		} else if(is_else_if($ecx)) {
			
		}else {
			console.log($ebx[e], "next");
			_block.data.push("if ;; @"   + $ecx);
			if ($ebx[e].op == "JMP") { ///下一个是JUMP
				if(is_else(e)) { ///是else
					return;
				} 
			}
			insert_nop_eof(e, _block);
		}
		
		
		//console.log("stack", jmp_stack, _block.tags_end);
	}catch(e) {
		console.log(e);
	}
}



function op_kpri (code, _block) {
	console.log(_block.symblos);
	try {
		var zero = 0;
		if(code.args[1]) {
			zero = code.args[1];
			
			if(zero == true) {
				zero = 1;
			}
		}
		
		var pc = inline_build_in_number(_block.data, 
										 zero,
										_block);
		_block.symblos.push({pc:pc, type:"KNUM"});
	}catch(e) {
		
	}
}


function op_mod (code, _block) {
	console.log(_block.symblos);
	try {
	var src =  _block.symblos[code.args[2]];
	var dst =  _block.symblos[code.args[1]];
	$ebx[$ecx].idx = code.args[0];
///eax
	if(!_block.symblos[code.args[0]]) {
		var pc = inline_build_in_number(_block.data, 0 , _block);
	    _block.symblos[code.args[0]]  = {pc:pc, type:"KNUM"};
		pc = pc - 8;
	} else {
		var pc = _block.symblos[code.args[0]].pc - 8; 
		if  (!pc) {
			pc  = 0;
		}
		
		if(pc < 0) {
			pc = 0;
		}
	}
	
	_block.data.push("i32.const " + pc + ";;;idx");
	
	if("MODVN" == code.op || "MODNV" == code.op) {
		var src = code.args[2] + "";
		if(src.indexOf(".") != -1) {
			src = src + ".0";
		}
		
		_block.data.push("f64.const " + src + ";;; const");
		_block.data.push("i32.trunc_s/f64");
		if("MODNV" == code.op) {
			_block.data.push("set_local 2");
		} else {
			_block.data.push("set_local 1");
		}
		
	} 
	else {	
		if(src) {
			get_value_from_symblos(src, _block);
			_block.data.push("i32.trunc_s/f64");
			_block.data.push("set_local 1");
		}
	}
	
	if(dst) {
		get_value_from_symblos(dst, _block);
		_block.data.push("i32.trunc_s/f64");
		
		if("MODNV" == code.op) {
			_block.data.push("set_local 1");
		} else {
			_block.data.push("set_local 2");
		}
	}
	_block.data.push("get_local 2");
	_block.data.push("get_local 1");
	
	_block.data.push("i32.rem_u " );
	_block.data.push("f64.convert_u/i32");
	_block.data.push("f64.store " );
	}catch(e) {
	}
}

/**
*  ret code
*/
function op_mov (code, _block) {
	//// 1 dst 操作数
	//// 0 堆栈数
	var dst = code.args[1];
	var line= find_nearest_stack_ele($ecx, dst);
	if(line) {
		$ebx[$ecx].idx = line.idx;
		//_block.data.push(";;;;;;;error stack0");
	} else {
		//_block.data.push(";;;;;;;error stack1");
		if($ebx[$ecx]) {
			$ebx[$ecx].idx =  code.args[1];
		}
	}
	
	if(!_block.symblos[dst]){
		//_block.data.push(";;;;;;;error stack2");
		_block.symblos[code.args[0]] =  _block.symblos[0];
		get_value_from_symblos( null , _block);
		/*
		var ele = find_mov_ele(code.args[0]);
		
		if(ele['idx'] != null) {
			get_value_from_symblos( _block.symblos[ele['idx']] , _block);
		}*/
	}
	_block.symblos[code.args[0]] = _block.symblos[dst];
}
function op_mul (code, _block) {
		//console.log(_block.symblos);
	var src  =  _block.symblos[code.args[2]];
	var dst  =  _block.symblos[code.args[1]];
	$ebx[$ecx].idx = code.args[0]; 
	try {
		
	if(!_block.symblos[code.args[0]]) {
		var pc = inline_build_in_number(_block.data, code.args[0], _block);
	    _block.symblos[code.args[0]]  = {pc:pc, type:"KNUM"};
		pc = pc -8;
		debug(_block, "op_mul::1");
	} else {
		var pc = _block.symblos[code.args[0]].pc - 8; 
		
		if  (!pc) {
			pc  = 0;
		}
		
		if(pc < 0) {
		 pc = 0;
		}
		debug(_block, "op_mul::2");
	}
	_block.data.push("i32.const " + pc  + ";;; op_mul :: save index");
	
	if("MULVN" == code.op || "MULNV" == code.op ) {
		var src = code.args[2] + "";
		if(src.indexOf(".") == -1) {
			src = src + ".0";
		}
		 
		_block.data.push("f64.const " + src + ";;; const");
	} else {
		if(src) {
			get_value_from_symblos(src, _block);
		}
	}
	
	if(dst) {
		get_value_from_symblos(dst, _block);
	}
	_block.data.push("f64.mul " );
	_block.data.push("f64.store ;;;end mul" );
	//_block.symblos[code.args[0]] = {}
	}catch (e) {
	}
}




/**
*  ret code
*/
function op_ret (code, _block) {
	//console.log("ebx=", $ebx);
	if(code.op == "RET0") {
		_block.data.push("f64.const 0.0");
		_block.data.push("return");
		return;
	}
	
	if(code.op == "RET1") {
		var rbase = find_nearest_stack_ele($ecx - 1,
										   code.args[0]);
		if(rbase) {
			var ret = _block.symblos[rbase.idx];
			if(ret) {
				get_value_from_symblos(ret, _block);
			} 
		} else {
			var ret = _block.symblos[code.args[0]];
			if(ret) {
				get_value_from_symblos(ret, _block);
			} 
		}
	}
	_block.data.push("return");
}


function op_sub (code, _block) {
	console.log(_block.symblos);
	try {
	var src =  _block.symblos[code.args[2]];
	var dst =  _block.symblos[code.args[1]];
	$ebx[$ecx].idx = code.args[0]; 

///eax
	if(!_block.symblos[code.args[0]]) {
		var pc = inline_build_in_number(_block.data, 0 , _block);
	    _block.symblos[code.args[0]]  = {pc:pc, type:"KNUM"};
		pc = pc - 8;
	} else {
		var pc = _block.symblos[code.args[0]].pc - 8; 
		if  (!pc) {
			pc  = 0;
		}
		
		if(pc < 0) {
			pc = 0;
		}
	}
	_block.data.push("i32.const " + pc + ";;;idx");
	if(dst) {
		if("SUBNV" == code.op) {
			var src = code.args[2] + "";
			if(src.indexOf(".") == -1) {
				src = src + ".0";
			}
			
			_block.data.push("i32.const " + src + ";;; const");
		}else {
			get_value_from_symblos(dst, _block);
		}
		
	}
	 
	if("SUBVN" == code.op) {
		var src = code.args[2] + "";
		if(src.indexOf(".") == -1) {
			src = src + ".0";
		}
		_block.data.push("f64.const " + src + ";;; const");
	} else {	
		if(src) {
			if("SUBNV" == code.op) {
				get_value_from_symblos(dst, _block);
			}else {
				get_value_from_symblos(src, _block);
			}
		}
	}
	_block.data.push("f64.sub " );
	_block.data.push("f64.store " );
	}catch(e) {
		
		console.log(e);
	}
}

// { op: 'TGETB', args: [ 2, 0, 1, 'index' ] },

function op_tget(code, _block) {

  var base = code.args[1];
  var key  = code.args[2]+"";
 
  if(code.op) {
    var obj = _block.symblos[base];
	//console.log(obj, "DDD");
    ///mov eax, ptr
    ///ptr + 12 -> data addr
    ///获取数据地址
    _block.data.push("i32.const " + (obj.pc-4>0? obj.pc-4: 0)) ;
    _block.data.push("set_local 0") ;
    _block.data.push("get_local 0") ;
    _block.data.push("i32.const 12");
    _block.data.push("i32.add");
   
    ///mov ebx , data[ptr]
    ///保存数据地址 base
	_block.data.push("i32.load") ;
    _block.data.push("set_local 1") ;
	
	////
	
    ///获取数据range
    _block.data.push("get_local 0") ;
    _block.data.push("i32.const 4");
    _block.data.push("i32.add");
    _block.data.push("i32.load");
    _block.data.push("set_local 2");
    ////key的地址
	var idx = look_up_table_key_tgetb(base,key);
	var pc = 0;
	var len= 0;
	if(!idx) {
		///进入8字节模式
		///进入动态字符模式 [TODO]
		pc = inline_build_in_number(_block.data, 
					code.args[2],
					_block);
		_block.symblos.push({pc:pc, type:"KNUM"});
		len= 8;
		/*pc = inline_build_in_cstr(_block.data, key, _block);
		 
		////key的长度

		len= (key+"").length 
		*/
		pc = pc - len;
		if(pc  < 0) {
			pc = 0;
		}
	
	} else {
		if(!_block.symblos[idx]) {
			console.log("null ptr3" , idx);
			return;
		}
		pc  = _block.symblos[idx].pc;
		////key的长度
		len= (key+"").length 
	}
	
    ///哈希函数
    ///内容都是指针
    _block.data.push(";;call hash") ;
    _block.data.push("i32.const " + pc  + ";; pc") ;
    _block.data.push("i32.const " + len + ";; len") ;
    _block.data.push("get_local 2;; range") ;
    _block.data.push("call $hash_str") ;
    
	//_block.data.push("set_local 3") ;
	//_block.data.push("get_local 3") ;
	//_block.data.push("call $print_i") ;
	//_block.data.push("get_local 3") ;
	////base + offset
  
	_block.data.push("i32.const 4");
	_block.data.push("i32.mul");
	_block.data.push("get_local 1"); 
	_block.data.push("i32.add ");
	///add result
	_block.data.push("set_local 9") ;
	_block.data.push("get_local 9") ;
	_block.data.push("call $print_i") ;
	_block.data.push("get_local 9") ;
	
	_block.data.push("i32.load ");
	
	_block.data.push("set_local 8") ;
	_block.data.push("get_local 8") ;
	_block.data.push("call $print_i") ;
  }
}


//  { op: 'TSETB', args: [ 1, 0, 1, 'newindex' ] },

// [1] is base
// [2] is value

function op_tset(code, _block) {

  var base = code.args[1];
  
  var key  = code.args[2]+"";
  
  if(code.args[3] == "newindex") {
    
    var obj = _block.symblos[base];
	
	//console.log(obj , "CCC");
    ///mov eax, ptr
    ///ptr + 12 -> data addr
    ///获取数据地址
    _block.data.push("i32.const " + (obj.pc-4>0? obj.pc-4: 0)) ;
    _block.data.push("set_local 0") ;
    _block.data.push("get_local 0") ;
    _block.data.push("i32.const 12");
    _block.data.push("i32.add");
    
    ///mov ebx , data[ptr]
    ///保存数据地址 base
	_block.data.push("i32.load") ;
    _block.data.push("set_local 1") ;

    
	///获取数据range
    _block.data.push("get_local 0") ;
    _block.data.push("i32.const 4");
    _block.data.push("i32.add");
    _block.data.push("i32.load");
    _block.data.push("set_local 2");
    ////key的地址
    var pc = inline_build_in_cstr(_block.data, 
      key, _block);
    ////key的长度
	
    var len= (key+"").length 
    
	pc = pc - len;
	if(pc  < 0) {
		pc = 0;
	}
	
	

    ///哈希函数
    ///内容都是指针
    _block.data.push(";;call hash") ;
    _block.data.push("i32.const " + pc + ";; len") ;
    //_block.data.push("get_local 0 ;; ptr") ;
    _block.data.push("i32.const " + len + ";; len") ;
    _block.data.push("get_local 2 ;; range") ;
    _block.data.push("call $hash_str") ;
    _block.data.push("set_local 3") ;
    ///base + offset
    _block.data.push("get_local 3") ;
	_block.data.push("i32.const 4") ;
	_block.data.push("i32.mul") ;
	_block.data.push("get_local 1") ; 
	_block.data.push("i32.add ") ;

     ///制作hash值
	
	//_block.data.push("set_local 4") ;
	//_block.data.push("get_local 3") ;
	//_block.data.push("call $print_i") ;
	//_block.data.push("get_local 4") ;
	
	var val_i =  look_up_table_value_tsetb (_block) - 8 ;
	
	if (val_i < 0) {
		val_i = 0;
	}
	
	//console.log(val_i, "idx");
	_block.data.push("i32.const " + val_i) ;
	
	 //_block.data.push("call $print_i") ;
	
	 _block.data.push("i32.store") ;
     //look_up_table_value
     ///[0] ptr
     ///[1] len
     ///[2] range
	 
  }
}



function op_tsetv(code, _block) {

  var base = code.args[1];
  if(code.args[3] == "newindex") {
 //    var key_idx   = code.args[2];
	
	// var key_idx2  = find_nearest_stack_ele_table_setv($ecx, key_idx);
	
	// if(!key_idx2) {
	// 	console.log("error:: null ptr 2");
	// 	return;
	// }
	// var len = 0;
	// var pc  = 0;
	
	// var type_ele = _block.symblos[key_idx2.idx];
	// if(key_idx2.idx && type_ele) { //key 的类型
	// 	if("KNUM" == type_ele.type) {
	// 		len = 8;
			
	// 		pc = type_ele.pc;
			
	// 		pc = pc - len;
	// 	}
	// }
	
	
	// if(pc  < 0) {
	// 	pc = 0;
	// }
	

	// ///由于类型是不可知的所以需要动态计算长度
	// ///数值型 8 
	// ///字符串 n*1
	
 //    var obj = _block.symblos[base];
	
	// //console.log(obj , "CCC");
 //    ///mov eax, ptr
 //    ///ptr + 12 -> data addr
 //    ///获取数据地址
 //    _block.data.push("i32.const " + (obj.pc-4>0? obj.pc-4: 0)) ;
 //    _block.data.push("set_local 0") ;
 //    _block.data.push("get_local 0") ;
 //    _block.data.push("i32.const 12");
 //    _block.data.push("i32.add");
    
 //    ///mov ebx , data[ptr]
 //    ///保存数据地址 base
	// _block.data.push("i32.load") ;
 //    _block.data.push("set_local 1") ;

    
	// ///获取数据range
 //    _block.data.push("get_local 0") ;
 //    _block.data.push("i32.const 4");
 //    _block.data.push("i32.add");
 //    _block.data.push("i32.load");
 //    _block.data.push("set_local 2");

    

	

    ///哈希函数
    ///内容都是指针
 //    _block.data.push(";;call hash") ;
 //    _block.data.push("i32.const " + pc + ";; pc") ;
 //    _block.data.push("i32.const " + len + ";; len") ;
 //    _block.data.push("get_local 2 ;; range") ;
 //    _block.data.push("call $hash_str") ;
 //    _block.data.push("set_local 3") ;
 //    ///base + offset
 //    _block.data.push("get_local 3") ;
	// _block.data.push("i32.const 4") ;
	// _block.data.push("i32.mul") ;
	// _block.data.push("get_local 1") ; 
	// _block.data.push("i32.add ") ;

     ///制作hash值
	//_block.data.push("set_local 4") ;
	//_block.data.push("get_local 4") ;
	//_block.data.push("call $print_i") ;
	//_block.data.push("get_local 4") ;
	
	// var val_i =  look_up_table_value_tsetb (_block) - 8;
	
	// if (val_i < 0) {
	// 	val_i = 0;
	// }
	// //{ op: 'TSETV', args: [ 4, 0, 4, 'newindex' ] },
	// //console.log(val_i, "idx");
	// _block.data.push("i32.const "  + val_i);
	// _block.data.push("f64.load ");
	///////获取到value
	
	//
	console.log(compile_num_v2p("KNUM", 1))
	//_block.data.push(build_in_ptr("KNUM", 1));
	
	//
	////idx call test
	// _block.data.push("call $print");
	 //_block.data.push("i32.const " + pc);
	
	////
	// _block.data.push("i32.store");
	// _block.data.push("get_local 0");
	// _block.data.push("i32.store");
     //look_up_table_value
     ///[0] ptr
     ///[1] len
     ///[2] range
	 
  }
}


// For mapping enum integer values to opcode names
var opcodes = [
  "ISLT", "ISGE", "ISLE", "ISGT", "ISEQV", "ISNEV", "ISEQS", "ISNES", "ISEQN",
  "ISNEN", "ISEQP", "ISNEP", "ISTC", "ISFC", "IST", "ISF", "MOV", "NOT", "UNM",
  "LEN", "ADDVN", "SUBVN", "MULVN", "DIVVN", "MODVN", "ADDNV", "SUBNV", "MULNV",
  "DIVNV", "MODNV", "ADDVV", "SUBVV", "MULVV", "DIVVV", "MODVV", "POW", "CAT",
  "KSTR", "KCDATA", "KSHORT", "KNUM", "KPRI", "KNIL", "UGET", "USETV", "USETS",
  "USETN", "USETP", "UCLO", "FNEW", "TNEW", "TDUP", "GGET", "GSET", "TGETV",
  "TGETS", "TGETB", "TSETV", "TSETS", "TSETB", "TSETM", "CALLM", "CALL",
  "CALLMT", "CALLT", "ITERC", "ITERN", "VARG", "ISNEXT", "RETM", "RET", "RET0",
  "RET1", "FORI", "JFORI", "FORL", "IFORL", "JFORL", "ITERL", "IITERL",
  "JITERL", "LOOP", "ILOOP", "JLOOP", "JMP", "FUNCF", "IFUNCF", "JFUNCF",
  "FUNCV", "IFUNCV", "JFUNCV", "FUNCC", "FUNCCW"
];

// For mapping opcode names to parse instructions
var bcdef = {
  ISLT: {ma: "var", md: "var", mt: "lt"},
  ISGE: {ma: "var", md: "var", mt: "lt"},
  ISLE: {ma: "var", md: "var", mt: "le"},
  ISGT: {ma: "var", md: "var", mt: "le"},
  ISEQV: {ma: "var", md: "var", mt: "eq"},
  ISNEV: {ma: "var", md: "var", mt: "eq"},
  ISEQS: {ma: "var", md: "str", mt: "eq"},
  ISNES: {ma: "var", md: "str", mt: "eq"},
  ISEQN: {ma: "var", md: "num", mt: "eq"},
  ISNEN: {ma: "var", md: "num", mt: "eq"},
  ISEQP: {ma: "var", md: "pri", mt: "eq"},
  ISNEP: {ma: "var", md: "pri", mt: "eq"},
  ISTC: {ma: "dst", md: "var"},
  ISFC: {ma: "dst", md: "var"},
  IST: {md: "var"},
  ISF: {md: "var"},
  MOV: {ma: "dst", md: "var"},
  NOT: {ma: "dst", md: "var"},
  UNM: {ma: "dst", md: "var", mt: "unm"},
  LEN: {ma: "dst", md: "var", mt: "len"},
  ADDVN: {ma: "dst", mb: "var", mc: "num", mt: "add"},
  SUBVN: {ma: "dst", mb: "var", mc: "num", mt: "sub"},
  MULVN: {ma: "dst", mb: "var", mc: "num", mt: "mul"},
  DIVVN: {ma: "dst", mb: "var", mc: "num", mt: "div"},
  MODVN: {ma: "dst", mb: "var", mc: "num", mt: "mod"},
  ADDNV: {ma: "dst", mb: "var", mc: "num", mt: "add"},
  SUBNV: {ma: "dst", mb: "var", mc: "num", mt: "sub"},
  MULNV: {ma: "dst", mb: "var", mc: "num", mt: "mul"},
  DIVNV: {ma: "dst", mb: "var", mc: "num", mt: "div"},
  MODNV: {ma: "dst", mb: "var", mc: "num", mt: "mod"},
  ADDVV: {ma: "dst", mb: "var", mc: "var", mt: "add"},
  SUBVV: {ma: "dst", mb: "var", mc: "var", mt: "sub"},
  MULVV: {ma: "dst", mb: "var", mc: "var", mt: "mul"},
  DIVVV: {ma: "dst", mb: "var", mc: "var", mt: "div"},
  MODVV: {ma: "dst", mb: "var", mc: "var", mt: "mod"},
  POW: {ma: "dst", mb: "var", mc: "var", mt: "pow"},
  CAT: {ma: "dst", mb: "rbase", mc: "rbase", mt: "concat"},
  KSTR: {ma: "dst", md: "str"},
  KCDATA: {ma: "dst", md: "cdata"},
  KSHORT: {ma: "dst", md: "lits"},
  KNUM: {ma: "dst", md: "num"},
  KPRI: {ma: "dst", md: "pri"},
  KNIL: {ma: "base", md: "base"},
  UGET: {ma: "dst", md: "uv"},
  USETV: {ma: "uv", md: "var"},
  USETS: {ma: "uv", md: "str"},
  USETN: {ma: "uv", md: "num"},
  USETP: {ma: "uv", md: "pri"},
  UCLO: {ma: "rbase", md: "jump"},
  FNEW: {ma: "dst", md: "func", mt: "gc"},
  TNEW: {ma: "dst", md: "lit", mt: "gc"},
  TDUP: {ma: "dst", md: "tab", mt: "gc"},
  GGET: {ma: "dst", md: "str", mt: "index"},
  GSET: {ma: "var", md: "str", mt: "newindex"},
  TGETV: {ma: "dst", mb: "var", mc: "var", mt: "index"},
  TGETS: {ma: "dst", mb: "var", mc: "str", mt: "index"},
  TGETB: {ma: "dst", mb: "var", mc: "lit", mt: "index"},
  TSETV: {ma: "var", mb: "var", mc: "var", mt: "newindex"},
  TSETS: {ma: "var", mb: "var", mc: "str", mt: "newindex"},
  TSETB: {ma: "var", mb: "var", mc: "lit", mt: "newindex"},
  TSETM: {ma: "base", md: "num", mt: "newindex"},
  CALLM: {ma: "base", mb: "lit", mc: "lit", mt: "call"},
  CALL: {ma: "base", mb: "lit", mc: "lit", mt: "call"},
  CALLMT: {ma: "base", md: "lit", mt: "call"},
  CALLT: {ma: "base", md: "lit", mt: "call"},
  ITERC: {ma: "base", mb: "lit", mc: "lit", mt: "call"},
  ITERN: {ma: "base", mb: "lit", mc: "lit", mt: "call"},
  VARG: {ma: "base", mb: "lit", mc: "lit"},
  ISNEXT: {ma: "base", md: "jump"},
  RETM: {ma: "base", md: "lit"},
  RET: {ma: "rbase", md: "lit"},
  RET0: {ma: "rbase", md: "lit"},
  RET1: {ma: "rbase", md: "lit"},
  FORI: {ma: "base", md: "jump"},
  JFORI: {ma: "base", md: "jump"},
  FORL: {ma: "base", md: "jump"},
  IFORL: {ma: "base", md: "jump"},
  JFORL: {ma: "base", md: "lit"},
  ITERL: {ma: "base", md: "jump"},
  IITERL: {ma: "base", md: "jump"},
  JITERL: {ma: "base", md: "lit"},
  LOOP: {ma: "rbase", md: "jump"},
  ILOOP: {ma: "rbase", md: "jump"},
  JLOOP: {ma: "rbase", md: "lit"},
  JMP: {ma: "rbase", md: "jump"},
  FUNCF: {ma: "rbase"},
  IFUNCF: {ma: "rbase"},
  JFUNCF: {ma: "rbase", md: "lit"},
  FUNCV: {ma: "rbase"},
  IFUNCV: {ma: "rbase"},
  JFUNCV: {ma: "rbase", md: "lit"},
  FUNCC: {ma: "rbase"},
  FUNCCW: {ma: "rbase"}
};

var kgctypes = ["CHILD", "TAB", "I64", "U64", "COMPLEX", "STR"];
var ktabtypes = ["NIL", "FALSE", "TRUE", "INT", "NUM", "STR"];
var kgcdecs = {
  TAB: function (parser) {
    var narray = parser.U();
    var nhash = parser.U();
    if (narray) {
      if (nhash) {
        throw new Error("TODO: implement mixed tables");
      }
      var tab = new Array(narray);
      for (var i = 0; i < narray; i++) {
        tab[i] = readktabk(parser);
      }
      return tab;
    }
    if (nhash) {
      var tab = {};
      for (var i = 0; i < nhash; i++) {
        var key = readktabk(parser);
        if (typeof key !== "string") throw new Error("TODO: Implement non-string keys");
        tab[key] = readktabk(parser);
      }
      return tab;
    }
    return {};
  },
  I64: function (parser) {
    throw new Error("TODO: Implement I64 kgc decoder");
  },
  U64: function (parser) {
    throw new Error("TODO: Implement U64 kgc decoder");
  },
  COMPLEX: function (parser) {
    throw new Error("TODO: Implement COMPLEX kgc decoder");
  },
  STR: function (parser, len) {
    len -= 5; // Offset for STR enum
    var value = parser.buffer.slice(parser.index, parser.index + len).toString();
    parser.index += len;
    return value;
  }
};
var ktabdecs = {
  NIL: function (parser) {
    return null;
  },
  FALSE: function (parser) {
    return false;
  },
  TRUE: function (parser) {
    return true;
  },
  INT: function (parser) {
    return parser.U();
  },
  NUM: readknum,
  STR: kgcdecs.STR
};
// Opcodes that consume a jump
var conditionals = {ISLT: true, ISGE: true, ISLE: true, ISGT: true, ISEQV: true,
  ISNEV: true, ISEQS: true, ISNES: true, ISEQN: true, ISNEN: true, ISEQP: true,
  ISNEP: true, ISTC: true, ISFC: true, IST: true, ISF: true};

// Used to consume bytes from a bytecode stream
function Parser(buffer) {
  this.buffer = buffer;
  this.index = 0;
  this.mark = 0;
}
Parser.prototype.B = function () {
  return this.buffer[this.index++];
};
// Consume 16 bit value from stream and move pointer
Parser.prototype.H = function () {
  var value = this.buffer.readUInt16LE(this.index);
  this.index += 2;
  return value;
};
// Consume 32 bit value from stream and move pointer
Parser.prototype.W = function () {
  var value = this.buffer.readUInt32LE(this.index);
  this.index += 4;
  return value;
};
// Decode ULEB128 from the stream
// http://en.wikipedia.org/wiki/LEB128
Parser.prototype.U = function () {
  var value = 0;
  var shift = 0;
  var byte;
  do {
    byte = this.buffer[this.index++];
    value |= (byte & 0x7f) << shift;
    shift += 7;
  } while (byte >= 0x80);
  return value >>> 0;
};

function parse(buffer) {
  var parser = new Parser(buffer);

  // header = ESC 'L' 'J' versionB flagsU [namelenU nameB*]
  if (parser.B() !== 0x1b) throw new Error("Expected ESC in first byte");
  if (parser.B() !== 0x4c) throw new Error("Expected L in second byte");
  if (parser.B() !== 0x4a) throw new Error("Expected J in third byte");
  if (parser.B() !== 1) throw new Error("Only version 1 supported");
  var flags = parser.U();
  if (flags & 1) throw new Error("Big endian encoding not supported yet");
  if (!(flags & 2)) throw new Error("Non stripped bytecode not supported yet");
  if (flags & 4) throw new Error("FFI bytecode not supported");

  // proto+
  var protoBuffers = [];
  do {
    var len = parser.U();
    protoBuffers.push(buffer.slice(parser.index, parser.index + len));
    parser.index += len;
  } while (buffer[parser.index]);

  // 0U and EOF
  if (parser.U() !== 0) throw new Error("Missing 0U at end of file");
  if (parser.index < buffer.length) throw new Error((buffer.length - parser.index) + " bytes leftover");

  var l = protoBuffers.length;
  var protos = new Array(l);
  for (var i = 0; i < l; i++) {
    readproto(protoBuffers[i], protos, i);
  }

  return protos;

}

function readproto(buffer, protos, protoIndex) {
  var parser = new Parser(buffer);

  // flagsB numparamsB framesizeB numuvB numkgcU numknU numbcU [debuglenU [firstlineU numlineU]]
  var flags = parser.B();
  var numparams = parser.B();
  var framesize = parser.B();
  var numuv = parser.B();
  var numkgc = parser.U();
  var numkn = parser.U();
  var numbc = parser.U();

  var bcins = new Array(numbc);
  var uvdata = new Array(numuv);

  var proto = protos[protoIndex] = {
    index: protoIndex,
    flags: flags,
    numparams: numparams,
    framesize: framesize,
    bcins: bcins,
    uvdata: uvdata
  };

  // bcinsW* uvdataH* kgc* knum*
  var i;
  for (i = 0; i < numbc; i++) {
    bcins[i] = parser.W();
  }
  for (i = 0; i < numuv; i++) {
    var uv = parser.H();
    uvdata[i] = {
      local: !!(uv & 0x8000),
      immutable: !!(uv & 0x4000),
      uv: uv & 0x3fff
    };
  }
  var constants = new Array(numkgc + numkn);
  var childc = protoIndex;
  for (i = 0; i < numkgc; i++) {
    var kgctype = parser.U();
    var type = kgctypes[kgctype] || "STR";
    if (type === "CHILD") {
      constants[i + numkn] = protos[--childc];
    }
    else {
      constants[i + numkn] = kgcdecs[type](parser, kgctype);
    }
  }
  for (i = 0; i < numkn; i++) {
    constants[i] = readknum(parser);
  }

  for (i = 0; i < numbc; i++) {
    bcins[i] = parseOpcode(bcins[i], i);
  }

  // Make sure we consumed all the bytes properly
  if (parser.index !== buffer.length) throw new Error((buffer.length - parser.index) + " bytes leftover");

  function parseArg(type, val, i) {
    switch (type) {
      case "lit": return val >>> 0;
      case "lits": return val & 0x8000 ? val - 0x10000 : val;
      case "pri": return val === 0 ? null : val === 1 ? false : true;
      case "num": return constants[val];
      case "str": case "tab": case "func": case "cdata":
        return constants[constants.length - val - 1];
      case "jump": return val - 0x8000;
      default: return val;
    }
  }

  function parseOpcode(word, i) {
    var opcode = opcodes[word & 0xff];
    var def = bcdef[opcode];
    var args = [];
    var op = {
      op: opcode,
      args: args
    };
    if (def.ma) {
      args.push(parseArg(def.ma, (word >>> 8) & 0xff, i));
    }
    if (def.mb) {
      args.push(parseArg(def.mb, word >>> 24, i));
    }
    if (def.mc) {
      args.push(parseArg(def.mc, (word >>> 16) & 0xff, i));
    }
    if (def.md) {
      args.push(parseArg(def.md, word >>> 16, i));
    }
    if (def.mt) {
      args.push(def.mt);
    }
    return op;
  }

}

function readknum(parser) {
  var isnum = parser.buffer[parser.index] & 1;
  var lo = parser.U() >> 1;
  if (isnum) {
    var buf = new Buffer(8);
    buf.writeUInt32LE(lo >>> 0, 0);
    buf.writeUInt32LE(parser.U(), 4);
    var num = buf.readDoubleLE(0);
    return num;
  }
  return lo;
}

// Read a constant table key or value
function readktabk(parser) {
  var ktabtype = parser.U();
  return ktabdecs[ktabtypes[ktabtype] || "STR"](parser, ktabtype);
}


/////
// std
////


var inlines_std_mem = [];

// 拷贝内存到另外一个目标
// dist  pc
// cpy   pc
// n     num
var inlines_onces = {
}
function require_copy_to_string () {
	if(inlines_onces["require_copy_to_string"]) {
		return;
	}
	var str = `
(func $copy_to_string (param i32 i32 i32)(result i32)
	(local i32 i32 i32 i32) 
	
	get_local 0 ;; n
	get_local 2 ;; ebx
	i32.add     ;; len = dist + n 
	set_local 2 ;; len = [2]
	
	loop $cont
		;;a[i] = b [j]
		get_local 0 ;; a[i]
		get_local 1 ;; n[j]
		i32.load8_u
		i32.store
		
		;; i++ 
		get_local 0
		i32.const 1
		i32.add 
		set_local 0
		
		;; j++ 
		get_local 1
		i32.const 1
		i32.add 
		set_local 1
		
		;; loop
		get_local 0 ;; i
		get_local 2 ;; len
		i32.le_u    ;; i <= len
		if 
			br $cont
		end
	end
	get_local 2
)
	`
	inlines_std_mem.push(str);
	inlines_onces["require_copy_to_string"] = true;
}


// 比较string是否相等
// src pc
// len n
// dst pc
// len n

// 首元素是否一致
// 尾元素是否一致
// 长度是否一致
// 遍历到最后

function require_str_cmp () {
	if(inlines_onces["require_str_cmp"]) {
		return;
	}
	var str = `
(func $str_cmp (param i32 i32 i32 i32)(result i32)
	(local i32 i32 i32 i32) 
	
	
	;;;frist ele eq
	
	get_local 0
	i32.load8_u
	get_local 2
	i32.load8_u
	i32.ne
	if 
		i32.const 0
		return
	end
	
	;;;len is eq
	get_local 1
	get_local 3
	i32.ne
	if 
		i32.const 0
		return
	end
	
	;;loop eq
	get_local 0 ;; n
	get_local 1 ;; ebx
	i32.add     ;; len = dist + n 
	set_local 3 ;; len = [3]
	
	loop $cont
		;;a[i] != b [j]
		get_local 0 ;; a[i]
		i32.load8_u
		get_local 2 ;; n[j]
		i32.load8_u
		i32.ne
		if 
			i32.const 0
			return 
		end
		
		;; i++ 
		get_local 0
		i32.const 1
		i32.add 
		set_local 0
		
		;; j++ 
		get_local 2
		i32.const 1
		i32.add 
		set_local 2
		
		
		;; loop
		get_local 0 ;; i
		get_local 3 ;; len
		i32.lt_u    ;; i <= len
		if 
			br $cont
		end
	end
	
	
	;; eq 
	i32.const 1
	return 
)
	`
	inlines_std_mem.push(str);
	inlines_onces["require_str_cmp"] = true;
}

///哈希函数
///[0] ptr
///[1] len
///[2] range
function require_hash () {
	if(inlines_onces["require_hash"]) {
		return;
	}
	var str = `
(func $hash_str (param i32 i32 i32)(result i32)
(local i32 i32 i32 i32 i32)
get_local 1
i32.const 3
i32.gt_s
if
get_local 1
i32.const -1
i32.xor
tee_local 5
i32.const -8
get_local 5
i32.const -8
i32.gt_s
select
get_local 1
i32.add
i32.const 4
i32.add
i32.const -4
i32.and
tee_local 6
get_local 0
get_local 1
tee_local 4
set_local 5
set_local 3
  loop
get_local 3
i32.load8_s offset=1
i32.const 8
i32.shl
get_local 3
i32.load8_s
i32.or
get_local 3
i32.load8_s offset=2
i32.const 16
i32.shl
i32.or
get_local 3
i32.load8_u offset=3
i32.const 24
i32.shl
i32.or
i32.const 1540483477
i32.mul
tee_local 7
i32.const 24
i32.shr_s
get_local 7
i32.xor
i32.const 1540483477
i32.mul
get_local 5
i32.const 1540483477
i32.mul
i32.xor
set_local 5
get_local 4
i32.const 7
i32.gt_s
    if
get_local 3
i32.const 4
i32.add
set_local 3
get_local 4
i32.const -4
i32.add
set_local 4
br 1
    end
  end
get_local 1
i32.const -4
i32.add
get_local 6
i32.sub
set_local 7
get_local 0
i32.add
i32.const 4
i32.add
set_local 6
  else
get_local 1
get_local 0
set_local 6
tee_local 5
set_local 7
end
block
  block
    block
      block
        block
          block
            block
get_local 7
i32.const 1
i32.sub
br_table 2 1 0 3
            end
get_local 6
i32.load8_s offset=2
tee_local 7
i32.const 16
i32.shl
get_local 5
i32.xor
set_local 5
br 3
          end
br 2
        end
br 2
      end
br 2
    end
get_local 6
i32.load8_s offset=1
tee_local 7
i32.const 8
i32.shl
get_local 5
i32.xor
set_local 5
  end
get_local 6
i32.load8_s
tee_local 7
get_local 5
i32.xor
i32.const 1540483477
i32.mul
set_local 5
end
get_local 5
i32.const 13
i32.shr_s
get_local 5
i32.xor
i32.const 1540483477
i32.mul
tee_local 5
i32.const 15
i32.shr_s
get_local 5
i32.xor
get_local 2
i32.rem_s
)
	`
	inlines_std_mem.push(str);
	inlines_onces["require_hash"] = true;
}


//// 动态分陪内存 * n

///动态内存位置就是 0
function require_alloc () {
	/////是否为null
	/////
	var str = `
	(func $copy_to_string (param i32 i32 i32)(result i32)
		(local i32 i32 i32 i32) 
		
		get_local 0 ;; n
		get_local 2 ;; ebx
		i32.add     ;; len = dist + n 
		set_local 2 ;; len = [2]
		
		loop $cont
			;;a[i] = b [j]
			get_local 0 ;; a[i]
			get_local 1 ;; n[j]
			i32.load8_u
			i32.store
			
			;; i++ 
			get_local 0
			i32.const 1
			i32.add 
			set_local 0
			
			;; j++ 
			get_local 1
			i32.const 1
			i32.add 
			set_local 1
			
			;; loop
			get_local 0 ;; i
			get_local 2 ;; len
			i32.le_u    ;; i <= len
			if 
				br $cont
			end
		end
		get_local 2
	)
	
	`
	inlines_std_mem.push(str);
}function set_value_from_symblos(node, _block) {
	if(node.pc - 8 < 0) {
		node.pc = 8;
	}
	_block.data.push("i32.const "+ (node.pc - 8));
	_block.data.push("f64.load ");
}

function get_value_from_static_section (svip) {
	var static_section_ele = const_section.symblos[svip];
	
	if(static_section_ele) {
		return static_section_ele[0];
	}
	
	return 0;
}


var $eax = 0;
var $ebx = 0;
var $ecx = 0;
var $edx = 0;

function look_up_table_key_tgetb (base, key) {
	var len = $ebx.length;
	for(var i = 0; i< len; i++) {
		if($ebx[i].args[1] == base) {
			if($ebx[i].args[2] == key) {
				return $ebx[i].idx;
			}
		}
	}
	///如果是setV进来的是不在符号表里的。
	
	return -1;
}

///all  pointers
function look_up_table_value_tsetb(_block) {
	var line = $ebx[$ecx-1];
	if(line) {
		if(line.idx) {
			var ele = _block.symblos[line.idx];
			if(ele) {
				return ele.pc ;
			}
		}
	}
	
	var line = $ebx[$ecx].args[2]
	
	if( _block.symblos[line] ) {
		return  _block.symblos[line].pc ;
	}
	
	console.log("not find tsetv ele");
	return 0;
	
}

function make_params_by_pointer(arr) {
	//console.log(arr);
	var global_stack  = [];
	var global_index  =  0;
	var global_string = 0;
	while((global_string = arr[global_index]) != null){
		//console.log(global_string, "call stack");
		if(global_string >= 0) { ////非引用
			global_stack[global_index++] = global_string;
		} else {
			global_stack[global_index++] = const_section.get(0-global_string);
		}
	}
	return global_stack;
}

function get_gloabl_var_by_name(name, _block) {
	//console.log(_block.symblos);
	/*var len = _block.symblos.length;
	var eax = _block.symblos;
	for(var i = 0; i< len; i++ ) {
		var ele = eax[i];
		
		if(ele.vname && ele.vname == name ) {
			return i;
		}
	}
	return -1;*/
	
	if (global[name]) {
		return global[name]
	}
	return null;
}

/////tag for end
function index_tag(ecx, _block) {
	var temp = peekTags(ecx, _block);
	var len  = temp.length ;
	if( len > 0) {
		for(var i = 0; i< len; i++) {
			addTagsEnd(_block, temp[i]);
		}
	}
}

/////选择tag
function peekTags (ecx, _block) {
  var t   = [];
  var eax = _block.tags_end;
  var len = eax.length;
  for(var i = 0; i< len ; i++) {
	 
	if(eax[i].num == ecx){
		t.push(eax[i]);
	}
  }
  return t;
}

////tag 结束
function addTagsEnd  (_block , item) {
	_block.data.push("end" + " ;;@" + item.tag);
}
//////
///TODO
function look_loop_tag (start, end) {
	for(var i = start ; i< end; i++ ){
		console.log(i, $ebx[i]);
	}
}

///向前看函数名
function look_at_function_name(dst , _block) {
	var len = $ecx;
	while (len -- >= 0) {
		var line = $ebx[len];
		if(line) {
			if (line.op == "GGET" &&
				line.args[0] == dst) {
				if(line.fname) {
					return line.fname 
				}
				return line.args[1];
			}
		}
	}
	return "$m" + _block.index;
}

function get_value_from_symblos(node, _block, oneR) {
	if(!node) {
		var pc = inline_build_in_number(_block.data, 0 ,_block);
		$ebx[$ecx].idx = _block.symblos.length;
		_block.symblos.push({pc:pc, type:"KNUM"});
		return pc;
	}
	if(node.pc - 8 < 0) {
		node.pc = 8;
	}
	switch (node.type) {
		case "KSTR":
			debug(_block, "str addr::");
			if(!oneR) {
				_block.data.push("i32.const "+ (node.pc));
				_block.data.push("i32.const "+ (node.size));
			} else {
				_block.data.push("f64.const 1.0");
			}
		break;
		default : ///Numberic
		
		//debug(_block, "numric addr::");
		_block.data.push("i32.const "+ (node.pc - 8));
		_block.data.push("f64.load ");
		break;
	}
	return node.pc;

}


function look_at_is_func(i) {
	return ($ebx[i - 1].op == "FNEW") ;
}

function look_at_is_var (i) {
	return ($ebx[i - 1].op.indexOf("K") != -1) ;
}

function look_at_make_callm_params2(code, _block) {
	var curr = $ecx - 1;
	
	var far  = code.args[0];
	var $base = $ebx[curr - far];
	
	console.log("base === " , $base);
	if($base.op == "GGET"){///全局
		if ($base.vname) {
			var ele = get_gloabl_var_by_name($base.vname, _block);
			get_value_from_symblos(ele ,_block);
		} else {
			_block.data.push("get_local 0 ;; base");
			_block.data.push("get_local 1 ;; size");
			//_block.data.push("f64.const 0.0 ;; null"); // null
		} 
		
	} else {
		///stack
		if($base.idx >= 0) {
			var dst = _block.symblos[$base.idx];
			if(dst) {
				get_value_from_symblos(dst, _block);
			} else {
				console.log("errr:::::");
			}
		}else {
			console.log("errr:::::");
		}
	}
}

function look_at_reg_for_table(_block) {
	_block.data.push("get_local 8");
	_block.data.push("i32.const 1");
	_block.data.push("i32.add");
	_block.data.push("call $print_i");
	
	_block.data.push("get_local 8");
	_block.data.push("f64.load");
}

function look_at_make_callm_params (n, _block) {
	var len  = n-1;
	//var len  = n;
	var temp = [];
	var start = $ecx - len;
	
	for(var i =start; i< $ecx; i++) {
		//console.log("push " + $ebx[i].idx);
		if(!$ebx[i]) {
			continue;
		}
		if($ebx[i].idx >= 0) {
			///dst 
			var dst = _block.symblos[$ebx[i].idx];
			//console.log("dst==11", dst, $ebx[i].idx);
			if(dst) {
				get_value_from_symblos(dst, _block);
			} else {
				console.log("errr:::::");
			}
		} else {
			//console.log("cc=" , $ebx[i]);
			if($ebx[i].op == "GGET"){///全局
				if ($ebx[i].vname) {
					var ele = get_gloabl_var_by_name($ebx[i].vname, _block);
					get_value_from_symblos(ele ,_block);
				} else {
					_block.data.push("get_local 0 ;; base");
					_block.data.push("get_local 1 ;; size");
					//_block.data.push("f64.const 0.0 ;; null"); // null
				}
			} else {
				
				if("TGETS" == $ebx[i].op) {
					look_at_reg_for_table(_block);
				} else {
					//_block.data.push(";;;caught the null"); // null
					_block.data.push("get_local 0 ;; base");
					_block.data.push("get_local 1 ;; size");
				}
				
			}
			
		}
	}
}

function look_at_make_call_params (n,  _block) {
	//var len  = n-1;
	var len  = n;
	var temp = [];
	var start = $ecx - len;
	
	for(var i =start; i< $ecx; i++) {
		//console.log("push " + $ebx[i].idx);
		if(!$ebx[i]) {
			continue;
		}
		
		if($ebx[i].idx >= 0) {
			///dst 
			var dst = _block.symblos[$ebx[i].idx];
			if(dst) {
				get_value_from_symblos(dst, _block);
			}
		} else {
			_block.data.push("f64.const " + $ebx[i].idx + ".0");
		}
	}
	console.log($ebx);
}

function find_mov_ele(n) {
	return $ebx[dist];
}

function find_fori_ele(n, dist) {
	var base = 0;
	var temp = [];
	for(var i = n ; i>= 0; i-- ) {
		if(!($ebx[i].op.charAt(0) == "K")) {
			continue;
		}
		
		if($ebx[i].args[0] == dist) {
			base = i;
		}
	}
	
	temp = [$ebx[base], $ebx[base + 1], $ebx[base+2]];
	return temp;
}

///查找最近的堆栈元素
function find_nearest_stack_ele_table_setv (n, dist) {
	for(var i = n - 1; i>= 0; i-- ) {
		//console.log($ebx[i])
		if(!$ebx[i].idx) {
			continue;
		}
		if($ebx[i].idx == dist) {
			return $ebx[i];
		}
	}
	return null;
}

///查找最近的堆栈元素
function find_nearest_stack_ele(n, dist) {
	for(var i = n ; i>= 0; i-- ) {
		if(!$ebx[i].idx) {
			continue;
		}
		if($ebx[i].args[0] == dist) {
			return $ebx[i];
		}
	}
	return null;
}

///向后看是否有call 指令
function look_at_hasCall () {
	var max = 10;
	for(var i = $ecx; i< max ; i++) {
		if($ebx[i].op.indexOf("CALL") != -1) {
			return true;
		}
	}
	return false;
}
var Flags = {  	
	"exceptions": false,
	"mutable_globals": true,
	"sat_float_to_int":false,
	"sign_extension":false,
	"simd":false,
	"threads":false,
	"multi_value":false,
	"tail_call":false    
};
								
////解释运行
function run_compc_main(code) {
	console.log("code=", code);
	
	if(!code) {
		code = "(module)";
	}
	var fs = require("fs");
	fs.writeFileSync("build/out.wat", code);
	return null;
}


var template = require("../template.js").template;

function run_comc_file_node (url) {
	
	var fs   = require("fs");
	var code = new Uint8Array(fs.readFileSync(url)).buffer;
	
	var buffer = Buffer(code);
    var protos = parse(buffer);
	console.log(protos);
	return run_compc_main(compile(protos));
}

var cases = [];
function test(name, result, condi) {
	cases .push({
		name:name, 
		result:result == condi,
		value :result
	});
}

function test_display() {
	var len =  cases.length;
	
	for(var i = 0; i<  len; i++ ) {
		console.log((i + 1), cases[i].name , cases[i].value , (cases[i].result?"[success]":"[failed]"));
	}
}

///calc
function testl0case() {
	console.log("testl0 is calc test");
	console.time("testl0case");
	
	// test("test/l0/def_var.luax", Number(run_comc_file_node("test/l0/def_var.luax")) >> 0 , 65536);
	// test("test/l0/def_const.luax", run_comc_file_node("test/l0/def_const.luax") , 30);
	
	//add
	// test("test/l0/def_add.luax", run_comc_file_node("test/l0/def_add.luax") , 30);
	// test("test/l0/def_add_sign.luax", run_comc_file_node("test/l0/def_add_sign.luax") , 30);
	// test("test/l0/def_add_l.luax", Number(run_comc_file_node("test/l0/def_add_l.luax")) >> 0 , -30);
	// test("test/l0/def_add_n.luax", Number(run_comc_file_node("test/l0/def_add_n.luax")) >> 0 , 30);
	
	//mul
	// test("test/l0/def_mul.luax", run_comc_file_node("test/l0/def_mul.luax") ,300);
	// test("test/l0/def_mul_sign.luax", Number(run_comc_file_node("test/l0/def_mul_sign.luax")) >> 0 , 314);
	// test("test/l0/def_mul_n.luax", Number(run_comc_file_node("test/l0/def_mul_n.luax")), 3000); 
	// test("test/l0/def_mul_l.luax", Number(run_comc_file_node("test/l0/def_mul_l.luax")), -3000); 
	
	//sub
	// test("test/l0/def_sub.luax", Number(run_comc_file_node("test/l0/def_sub.luax")) >> 0 ,30);
	// test("test/l0/def_sub_sign.luax", Number(run_comc_file_node("test/l0/def_sub_sign.luax")) >> 0 , 300);
	// test("test/l0/def_sub_n.luax", Number(run_comc_file_node("test/l0/def_sub_n.luax")) >> 0 ,30);
	// test("test/l0/def_sub_l.luax", Number(run_comc_file_node("test/l0/def_sub_l.luax")) >> 0 ,-30);
	
	//div
	// test("test/l0/def_dev.luax", Number(run_comc_file_node("test/l0/def_dev.luax")) >> 0 ,30);
	// test("test/l0/def_dev_sign.luax", Math.floor(Number(run_comc_file_node("test/l0/def_dev_sign.luax"))) ,99);
	// test("test/l0/def_dev_n.luax", Math.floor(Number(run_comc_file_node("test/l0/def_dev_n.luax"))) ,30);
	//test("test/l0/def_dev_l.luax", Math.floor(Number(run_comc_file_node("test/l0/def_dev_l.luax"))) ,30);
	
	//mod
	// test("test/l0/def_mod.luax", Math.floor(Number(run_comc_file_node("test/l0/def_mod.luax"))) ,1);
	// test("test/l0/def_mod_l.luax", Math.floor(Number(run_comc_file_node("test/l0/def_mod_l.luax"))) ,1);
	test("test/l0/def_mod_sign.luax", Math.floor(Number(run_comc_file_node("test/l0/def_mod_sign.luax"))) ,1);
	

	console.timeEnd("testl0case");
	test_display();
}

//////func call
function testl1case() {
	console.log("testl1 is calc test");
	console.time("testl1case");
	
	// test("test/l1/nil.luax", Number(run_comc_file_node("test/l1/nil.luax")) >> 0 , 0);
	// test("test/l1/blooean.luax", Number(run_comc_file_node("test/l1/blooean.luax")) >> 0 , 1);
	// test("test/l1/string.luax", Number(run_comc_file_node("test/l1/string.luax")) >> 0 , 0);
	// test("test/l1/string_print.luax", Number(run_comc_file_node("test/l1/string_print.luax")) >> 0 , -1);
	
	///func test
	// test("test/l1/i32_put.luax", Number(run_comc_file_node("test/l1/i32_put.luax")) >> 0 , 0);
	// test("test/l1/i32_put_val.luax", Number(run_comc_file_node("test/l1/i32_put_val.luax")) >> 0 , 0);
	
	//inline call
	// test("test/l1/sub_func.luax", Number(run_comc_file_node("test/l1/sub_func.luax")) >> 0 , 5);
	//test("test/l1/add_func.luax", Number(run_comc_file_node("test/l1/add_func.luax")) >> 0 , 5);
	//test("test/l1/mul_func.luax", Number(run_comc_file_node("test/l1/mul_func.luax")) >> 0 , 5);
	//test("test/l1/div_func.luax", Number(run_comc_file_node("test/l1/div_func.luax")) >> 0 , 5);
	// test("test/l1/inline_fun_add.luax", Number(run_comc_file_node("test/l1/inline_fun_add.luax")) >> 0 , 1);
	// test("test/l1/mod_func.luax", Number(run_comc_file_node("test/l1/mod_func.luax")) >> 0 , 1);
	// test("test/l1/calc.luax", Number(run_comc_file_node("test/l1/calc.luax")) >> 0 , 1);
	
	console.timeEnd("testl1case");
	test_display();
}

//logic
function testl2case() {
	console.log("testl2 is calc test");
	console.time("testl2case");
	
	// test("test/l2/max.luax", Number(run_comc_file_node("test/l2/max.luax")) >> 0 , 0);
	// test("test/l2/ret1.luax", Number(run_comc_file_node("test/l2/ret1.luax")) >> 0 , 0);
	// test("test/l2/if_elif.luax", Number(run_comc_file_node("test/l2/if_elif.luax")) >> 0 , 0);
	// test("test/l2/if_lt.luax", Number(run_comc_file_node("test/l2/if_lt.luax")) >> 0 , 0);
	// test("test/l2/if_ge.luax", Number(run_comc_file_node("test/l2/if_ge.luax")) >> 0 , 0);
	// test("test/l2/if_gt.luax", Number(run_comc_file_node("test/l2/if_gt.luax")) >> 0 , 0);
	// test("test/l2/if_eq.luax", Number(run_comc_file_node("test/l2/if_eq.luax")) >> 0 , 0);
	// test("test/l2/case1.luax", Number(run_comc_file_node("test/l2/case1.luax")) >> 0 , 0);
	///bad case
	
	//test("test/l2/fib401.luax", Number(run_comc_file_node("test/l2/fib401.luax")) >> 0 , 1);
	//test("test/l2/fib402.luax", Number(run_comc_file_node("test/l2/fib402.luax")) >> 0 , 1);
	console.timeEnd("testl2case");
	test_display();
}

//loop
function testl3case() {
	console.log("testl3 is loop test");
	console.time("testl3case");
	
	// test("test/l3/for3.luax", Number(run_comc_file_node("test/l3/for3.luax")) >> 0 , 0);
	// test("test/l3/for.luax", Number(run_comc_file_node("test/l3/for.luax")) >> 0 , 0);
	//test("test/l3/for2.luax", Number(run_comc_file_node("test/l3/for2.luax")) >> 0 , 0);
	
	///bad case
	// test("test/l3/while.luax", Number(run_comc_file_node("test/l3/while.luax")) >> 0 , 0);
	
	console.timeEnd("testl3case");
	test_display();
}

///string
function testl4case() {
	// test("test/l4/require.luax", Number(run_comc_file_node("test/l4/require.luax")) >> 0 , 0);
	// test("test/l4/string_set.luax", Number(run_comc_file_node("test/l4/string_set.luax")) >> 0 , 0);
	//test("test/l4/string_unpas.luax", Number(run_comc_file_node("test/l4/string_unpas.luax")) >> 0 , 0);
	//test("test/l4/string_eq.luax", Number(run_comc_file_node("test/l4/string_eq.luax")) >> 0 , 0);
	//test("test/l4/string_eq_not_pass.luax", Number(run_comc_file_node("test/l4/string_eq_not_pass.luax")) >> 0 , 0);
	//test("test/l4/string_eq_not_pass2.luax", Number(run_comc_file_node("test/l4/string_eq_not_pass2.luax")) >> 0 , 0);
	//test("test/l4/string_neq.luax", Number(run_comc_file_node("test/l4/string_neq.luax")) >> 0 , 0);
	//test("test/l4/string_not.luax", Number(run_comc_file_node("test/l4/string_not.luax")) >> 0 , 0);
	//test("test/l4/table_set.luax", Number(run_comc_file_node("test/l4/table_set.luax")) >> 0 , 0);
	//test("test/l4/table_update.luax", Number(run_comc_file_node("test/l4/table_update.luax")) >> 0 , 0);
	//test("test/l4/table_set_unpass.luax", Number(run_comc_file_node("test/l4/table_set_unpass.luax")) >> 0 , 0);
	
	//test("test/l4/table_set_benchi_unpass.luax", Number(run_comc_file_node("test/l4/table_set_benchi_unpass.luax")) >> 0 , 0);
	//test("test/l4/table_set_benchi.luax", Number(run_comc_file_node("test/l4/table_set_benchi.luax")) >> 0 , 0);
	// test("test/l4/table_incr.luax", Number(run_comc_file_node("test/l4/table_incr.luax")) >> 0 , 0);
	//bad case
	test_display();
}
testl4case();
// testl3case();
//testl2case();
// testl0case();
// testl2case();

